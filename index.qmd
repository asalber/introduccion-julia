---
title: "Introducci√≥n Julia"
subtitle: "Orientada a computaci√≥n cient√≠fica y an√°lisis de datos"
format: 
    revealjs:
        theme: [dark, custom.scss]
        logo: img/logos/logo-julia.svg
        navigation-mode: vertical
        footer: <https://aprendeconalf.es/introduccion-julia>
        code-line-numbers: false
        code-tools:
            code-block-bg: true
            code-block-border-Izquierda: "#31BAE9"
        highlight-style: monokai
        callout-appearance: simple
execute: 
  echo: true
---

# Introducci√≥n a Julia

## ¬øPor qu√© Julia?

[Julia](https://julialang.org/) es otro lenguaje de programaci√≥n m√°s, orientado a c√°lculo cient√≠fico el an√°lisis de datos similar a Python, R o Matlab.

::: {.fragment .r-stack}
_¬øDe veras necesitamos aprender otro lenguaje m√°s?_
:::

## ¬øQu√© pretende ser Julia?

De los creadores de Julia:

>_We want a language that is:_
>
- _Open source._
- _With the speed of C._
- _Obvious, familiar mathematical notation like Matlab._
- _As usable for general programming as Python._
- _As easy for statistics as R._
- _As natural for string processing as Perl._
- _As powerful for linear algebra as Matlab._
- _As good at gluing programs together as the shell._
- _Dirt simple to learn, yet keeps the most serious hackers happy._

## ¬øQu√© es Julia?

- Julia es un lenguaje de alto nivel con una sintaxis f√°cil de aprender (similar a Python, R o Matlab) que permite escribir s√≠mbolos matem√°ticos en las expresiones (UTF-8).
- Julia es un lenguaje muy veloz (equiparable a C en muchas tareas.)
- Lenguaje din√°mico (tipado din√°mico y despacho m√∫ltiple).
- De prop√≥sito general, pero orientado a la computaci√≥n cient√≠fica y el an√°lisis de grandes vol√∫menes de datos.
- Creado en 2019 en el MIT por el equipo del profesor Edelman.
- √öltima versi√≥n: 1.7 (bastante maduro).
- Desarrollado por una gran [comunidad cient√≠fica](https://julialang.org/community/).
- [Repositorio de paquetes](https://julialang.org/packages/) de c√≥digo abierto con m√°s de 3000 paquetes en dominios muy diversos.

---

### Comparativa de rapidez de Julia con otros lenguajes

![Comparativa de Julia con otros lenguajes](./img/benchmarks.svg)

## Algunas razones m√°s para pens√°rselo

- Evita el problema de la doble reescritura de c√≥digo (prototipo + versi√≥n operativa).
- Permite la programaci√≥n paralela y distribuida.
- Puede ejecutar c√≥digo realizado en otros lenguajes como C, Fortran, Python, R, Matlab, etc.

## Instalaci√≥n de Julia

1. [Descargar e instalar Julia](https://julialang.org/downloads/).
2. A√±adir Julia al PATH del sistema.

Una vez instalado, para ejecutar el int√©rprete de Julia basta con abrir una terminal y teclear `julia`.

```bash
prompt> julia
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.7.3 (2022-05-06)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia> 
```

## El REPL de Julia

El REPL^[Read, Evaluate, Print and Loop] de Julia permite ejecutar c√≥digo de Julia tecle√°ndolo directamente en la terminal. 

```bash
julia> 2 + 3
5
```

Tiene, adem√°s, varios modos:

- `;` para abrir el modo shell.
- `]` para abrir el modo de gesti√≥n de paquetes.
- `?` para abrir el modoe de ayuda.to open help mode
- `<backspace>` para volver al modo normal.


## IDEs para Julia

![](img/julia-ides.png)

---

### [Visual studio code](https://code.visualstudio.com/)

- [Descargar e instalar VSCode](https://code.visualstudio.com/Download).
- [Instalar la extensi√≥n de Julia](https://www.julia-vscode.org/).

---

![Visual Studio Code con la extensi√≥n para Julia](img/vscode.png)

---

### [Jupyter](https://jupyter.org/)

- [Descargar e instalar Python](https://www.python.org/downloads/)
- [Descargar e instalar Jupyter](https://jupyter.org/install)
- Instalar el paquete IJulia:
```julia
julia> using Pkg
julia> Pkg.add("IJulia")
```
---

![Jupyter con el kernel de Julia](img/jupyter.png)

# Tipos de datos y variables

## Tipos de datos num√©ricos

- Enteros: `Int64` (64 bits por defecto).
- Racionales: `Rational{Int64}`. Utilizando el operador `//`.
- Reales: `Float64` (64 bits por defecto).
- Complejos: `Complex{Int64}`. Utilizando `im` despu√©s de la parte imaginaria.

Para averiguar el tipo de un dato se utiliza la funci√≥n `typeof()`.

---

## Ejemplos de tipos de datos num√©ricos

```julia
julia> typeof(3)
Int64

julia> typeof(3/2)
Float64

julia> typeof(3//2)
Rational{Int64}

julia> typeof(œÄ)
Irrational{:œÄ}

julia> typeof(3+2im)
Complex{Int64}
```

## Jerarqu√≠a de tipos de datos num√©ricos

![](img/tipos-datos-numericos.png)

## Constantes predefinidas

| S√≠mbolo | Descripci√≥n           |
|:---------- |:-------------- |
| `pi` o `œÄ`    | N√∫mero irracional $\pi$                   |
| `‚ÑØ` (\\euler + TAB)    | N√∫mero irracional $e$                    |
| `Inf`    | Infinito                 |
| `NaN`    | Valor no num√©rico                       |
| `Missing`    | Valor desconocido         |

---

## Ejemplo de constantes predefinidas

```julia
julia> œÄ
œÄ = 3.1415926535897...

julia> 1 / 0
Inf

julia> 0 / 0
NaN

julia> Inf + Inf
Inf

julia> Inf - Inf
NaN

julia> 0 * Inf
NaN
```

## Tipos de datos alfanum√©ricos

- car√°cteres: `Char`. Se representan entre comillas simples.
- Cadenas: `String`. Se representan entre comillas dobles.

```julia
julia> typeof('a')
Char

julia> typeof("julia")
String

julia> typeof("a")
String
```

## Tipo de datos booleanos

- Booleanos: `bool`. Son un subtipo de los enteros `Integer`.

Solo contienen dos posibles valores: `true` (1) y `false` (0).

```julia
julia> typeof(true)
Bool

julia> typeof(false)
Bool

julia> typeof(1 < 2)
Bool

julia> true + true
2
```

## Variables

Como lenguaje de tipado din√°mico, no es necesario declarar una variable antes de usarla. Su tipo se infiere directamente del valor asociado.

```julia
julia> x = 1
1

julia> typeof(x)
Int64

julia> x = "julia"
"julia"

julia> typeof(x)
String
```

No obstante, para variables de √°mbito local, por ejemplo en funciones, es posible fijar el tipo de una variable indic√°ndolo detras de su nombre con el operador `::`.

```julia
x::Int64
```

<!-- TODO: ## Conversi√≥n de tipos -->

## Nombres de variables

Julia reconoce la codificaci√≥n Unicode (UTF-8), lo que permite utilizar caracteres con tildes, letras griegas, s√≠mbolos matem√°ticos y hasta emoticonos en los nombres de variables o funciones. Para ello se utilizan [c√≥digos especiales](https://docs.julialang.org/en/v1/manual/unicode-input/) (en muchos casos son los mismos que en $\LaTeX$), pulsando despu√©s la tecla de tabulaci√≥n.

```julia
julia> Œ± = 1
1

julia> Œ≤ = 2
2

julia> Œ± + Œ≤
3

julia> üòÑ = "julia"
"julia"
```

Distingue entre may√∫sculas y min√∫sculas.

## Operadores aritm√©ticos

| Operador | Descripci√≥n           |
|:---------- |:-------------- |
| `x + y`    | Suma                       |
| `x - y`    | Resta                    |
| `x * y`    | Producto                 |
| `x / y`    | Divisi√≥n                       |
| `x √∑ y`    | Cociente divisi√≥n entera          |
| `x % y`    | Resto divisi√≥n entera                |
| `x ^ y`    | Potencia           |

## Operadores de comparaci√≥n

| Operador                   | Descripci√≥n                     |
|:---------------------------- |:------------------------ |
| `==`                 | Igualdad                 |
| `!=`, `‚â†` | Desigualdad               |
| `<`                  | Menor que                |
| `<=`, `‚â§` | Menor o igual que    |
| `>`                  | Mayor que             |
| `>=`, `‚â•` | Mayor o igual que |

## Operadores booleanos

| Operador | Descripci√≥n |
|:---------- |:------------------------------|
| `!x` | Negaci√≥n             |
| `x && y`   | Conjunci√≥n (y)|
| `x || y` | Disyunci√≥n (o)  |

## Funciones num√©ricas predefinidas

### Funciones de redondeo

| Funci√≥n         | Descripci√≥n                        |
|:--------------------- |:-----------------------------|
| `round(x)`    | Devuelve el entero m√°s pr√≥ximo a `x` |
| `round(x, digits = n)`    | Devuelve al valor m√°s pr√≥ximo a `x` con `n` decimales |
| `floor(x)`    | Redondea `x` al pr√≥ximo entero menor |
| `ceil(x)`     | Redondea `x` al pr√≥ximo entero mayor |
| `trunc(x)`    | Devuelve la parte entera de `x`      |

---

### Ejemplo de funciones de redondeo

```julia
julia> round(2.7)
3.0

julia> floor(2.7)
2.0

julia> floor(-2.7)
-3.0

julia> ceil(2.7)
3.0

julia> ceil(-2.7)
-2.0

julia> trunc(2.7)
2.0

julia> trunc(-2.7)
-2.0

julia> round(2.5)
2.0

julia> round(2.786, digits = 2)
2.79
```

---

### Funciones de divisi√≥n

| Funci√≥n                  | Descripci√≥n                                                                                               |
|:------------------------- |:--------------------------------------------------------------------------------------------------------- |
| `div(x,y)`, `x√∑y` | Cociente de la divisi√≥n entera                                                         |
| `fld(x,y)`        | Cociente de la divisi√≥n entera redondeado hacia abajo               |
| `cld(x,y)`        | Cociente de la divisi√≥n entera redondeado hacia arriba                                                         |
| `rem(x,y)`, `x%y` | Resto de la divisi√≥n entera. Se cumple `x == div(x,y)*y + rem(x,y)`                                       |
| `mod(x,y)`        | M√≥dulo con respecto a `y`. Se cumple `x == fld(x,y)*y + mod(x,y)`                                        |
| `gcd(x,y...)`    | M√°ximo com√∫n divisor positivo de `x`, `y`,...                                                          |
| `lcm(x,y...)`   | M√≠nimo com√∫n m√∫ltiplo positivo de `x`, `y`,...                                                            |

---

### Ejemplo de funciones de divisi√≥n

```julia
julia> div(5,3)
1

julia> cld(5,3)
2

julia> 5%3
2

julia> -5%3
-2

julia> mod(5,3)
2

julia> mod(-5,3)
1

julia> gcd(12,18)
6

julia> lcm(12,18)
36
```

---

### Funciones para el signo y el valor absoluto

| Funci√≥n                | Descripci√≥n                                                |
|:----------------------- |:---------------------------------------------------------- |
| `abs(x)`        | Valor absoluto de `x`                 |
| `sign(x)`       | Devuelve -1 si `x` es positivo, -1 si es negativo y 0 si es 0.       |

```julia
julia> abs(2.5)
2.5

julia> abs(-2.5)
2.5

julia> sign(-2.5)
-1.0

julia> sign(0)
0

julia> sign(2.5)
1.0
```

---

### Ra√≠ces, exponenciales y logaritmos

| Funci√≥n                | Descripci√≥n                                                                |
|:------------------------ |:-------------------------------------------------------------------------- |
| `sqrt(x)`, `‚àöx`  | Ra√≠z cuadrada de `x`                                                         |
| `cbrt(x)`, `‚àõx`  | Ra√≠z c√∫bica de `x`                                                           |
| `exp(x)`         | Exponencial de `x`                                        |
| `log(x)`         | Logaritmo neperiano de `x`                                                   |
| `log(b,x)`       | Logaritmo en base `b` de `x`                                                  |
| `log2(x)`        | Logaritmo en base 2 de `x`                                                    |
| `log10(x)`       | Logaritmo en base 10 de `x`                                                   |

---

### Ejemplo de ra√≠ces, exponenciales y logaritmos

```julia
julia> sqrt(4)
2.0

julia> cbrt(27)
3.0

julia> exp(1)
2.718281828459045

julia> exp(-Inf)
0.0

julia> log(1)
0.0

julia> log(0)
-Inf

julia> log(-1)
ERROR: DomainError with -1.0:
log will only return a complex result if called with a complex argument.
...

julia> log(-1+0im)
0.0 + 3.141592653589793im

julia> log2(2^3)
3.0
```

---

### Funciones trigonom√©tricas

| Funci√≥n                | Descripci√≥n                                                                |
|:------------------------ |:-------------------------------------------------------------------------- |
| `hypot(x,y)`     | Hipotenusa del tri√°ngulo rect√°ngulo con catetos `x` e `y` |
| `sin(x)`  | Seno del √°ngulo `x` en radianes                                                        |
| `sind(x)`  | Seno del √°ngulo `x` en grados                                                          |
| `cos(x)`         | Coseno del √°ngulo `x` en radianes                                       |
| `cosd(x)`         | Coseno del √°ngulo `x` en grados                                                  |
| `tan(x)`       | Tangente del √°ngulo `x` en radianes                                                  |
| `tand(x)`       | Tangente del √°ngulo `x` en grados                                                  |
| `sec(x)`        | Secante del √°ngulo `x` en radianes                                                 |
| `csc(x)`        | Cosecante del √°ngulo `x` en radianes                                                 |
| `cot(x)`       | Cotangente del √°ngulo `x` en radianes                                                  |

---

### Ejemplo de funciones trigonom√©tricas

```julia
julia> sin(œÄ/2)
1.0

julia> cos(œÄ/2)
6.123233995736766e-17

julia> cosd(90)
0.0

julia> tan(œÄ/4)
0.9999999999999999

julia> tand(45)
1.0

julia> tan(œÄ/2)
1.633123935319537e16

julia> tand(90)
Inf

julia> sin(œÄ/4)^2 + cos(œÄ/4)^2
1.0
```

---

### Funciones trigonom√©tricas inversas

| Funci√≥n                | Descripci√≥n                                                                |
|:------------------------ |:-------------------------------------------------------------------------- |
| `asin(x)`        | Arcoseno (inversa del seno) de `x` en radianes                                                 |
| `asind(x)`        | Arcoseno (inversa del seno) de `x` en grados                                                 |
| `acos(x)`       | Arcocoseno (inversa del coseno) de `x` en radianes                                                  |
| `acosd(x)`       | Arcocoseno (inversa del coseno) de `x` en grados                                                  |
| `atan(x)` | Arcotangente (inversa de la tangente) de `x` en radianes |
| `atand(x)` | Arcotangente (inversa de la tangente) de `x` en grados |
| `asec(x)` | Arcosecante (inversa de la secante) de `x` en radianes |
| `acsc(x)` | Arcocosecante (inversa de la cosecante) de `x` en radianes |
| `acot(x)` | Arcocotangente (inversa de la cotangente) de `x` en radianes |

---

### Ejemplo de funciones trigonom√©tricas inversas

```julia
julia> asin(1)
1.5707963267948966

julia> asind(1)
90.0

julia> acos(-1)
3.141592653589793

julia> atan(1)
0.7853981633974483

julia> atand(tan(œÄ/4))
45.0
```

## Precedencia de operadores

De mayor a menor prioridad.

| Categor√≠a       | Operadores                                                                                      | Asociatividad              |
|:-------------- |:------------------------------------------------------------------------------------------------- |:-------------------------- |
| Exponenciaci√≥n | `^`                                                                                               | Derecha                      |
| Unarios          | `+ - ‚àö`                                                                                           | Derecha                |
| Fracciones     | `//`                                                                                              | Izquierda                       |
| Multiplicaci√≥n | `* / % & \ √∑`                                                                                     | Izquierda                |
| Adici√≥n       | `+ - |` | Izquierda  |
| Comparaciones    | `> < >= <= == != !==`                                                                      |            |
| Asignaciones    | `= += -= *= /= //= ^= √∑= %= |= &=`                                            | Derecha                      |

## Operaciones con cadenas

Las cadenas son secuencias de car√°cteres alfanum√©ricos del tipo `char` entre dobles comillas.

Cada car√°cter tiene asociado un √≠ndice entero. El primer car√°cter de la cadena tiene √≠ndice 1. 

| | | | | | |
|:-|:-:|:-:|:-:|:-:|:-:|
|√çndice | 1 | 2 | 3 | 4 | 5 |
|Cadena | j | u | l | i | a |

Podemos acceder a cada car√°cter usando su √≠ndice entre corchetes a continuaci√≥n de la cadena:

- `s[i]`: Devuelve el car√°cter con √≠ndice `i` en la cadena `s`.

```julia
julia> c = "julia"
"julia"

julia> c[2]
'u': ASCII/Unicode U+0075 (category Ll: Letter, lowercase)
```

---

### Acceso a car√°cteres Unicode

Sin embargo, como Julia permite car√°cteres [Unicode](https://en.wikipedia.org/wiki/List_of_Unicode_characters), el √≠ndice de un car√°cter en una cadena, no siempre se corresponde con su posici√≥n en la cadena. Ello es debido a que la codificaci√≥n UTF-8 no utiliza el mismo n√∫mero de bytes para representar los car√°cteres Unicode. Mientras que los car√°cteres habituales del c√≥digo ASCII (letras romanas y n√∫meros √°rabes) solo necesitan un byte, otros car√°cteres como los s√≠mbolos matem√°ticos requieren m√°s.

| | | | | | |
|:-|:-:|:-:|:-:|:-:|:-:|
|√çndice | 1 | 4 | 5 | 6 | 9 |
|Cadena | ‚àÄ | x |   | ‚àÉ | y |

---

### Ejemplo de acceso a car√°cteres Unicode

```julia
julia> c = "‚àÄx ‚àÉy"
"‚àÄx ‚àÉy"

julia> c[1]
'‚àÄ': Unicode U+2200 (category Sm: Symbol, math)

julia> c[2]
ERROR: StringIndexError: invalid index [2], 
valid nearby indices [1]=>'‚àÄ', [4]=>'x'
Stacktrace:
 [1] string_index_err(s::String, i::Int64)
   @ Base ./strings/string.jl:12
 [2] getindex_continued(s::String, i::Int64, u::UInt32)
   @ Base ./strings/string.jl:233
 [3] getindex(s::String, i::Int64)
   @ Base ./strings/string.jl:226
 [4] top-level scope
   @ REPL[128]:1
```

---

### Acceso a √≠ndices en cadenas

Las siguientes funciones permiten acceder a los √≠ndices de una cadena:

- `firsindex(c)`: Devuelve el √≠ndice del primer car√°cter de la cadena `c`.
- `lastindex(c)`: Devuelve el √≠ndice del primer car√°cter de la cadena `c`.
- `nextind(c, i)`: Devuelve el √≠ndice del car√°cter de la cadena `c` que sigue al car√°cter con √≠ndice `i`.
- `prevind(c, i)`: Devuelve el √≠ndice del car√°cter de la cadena `c` que sigue al car√°cter con √≠ndice `i`.

---

### Ejemplo de acceso a √≠ndices en cadenas

```julia
julia> firstindex(c)
1

julia> lastindex(c)
9

julia> c[9]
'y': ASCII/Unicode U+0079 (category Ll: Letter, lowercase)

julia> nextind(c,1)
4

julia> prevind(c, lastindex(c))
6
```

---

### Subcadenas

Para obtener subcadenas se usan tambi√©n los corchetes indicando los √≠ndices de inicio y fin separados por `:`.

- `s[i:j]`: Devuelve la subcadena que va desde el √≠ndice `i` al √≠ndice `j`, ambos incluidos.

Tambi√©n se pueden obtener subcadenas con la siguiente funci√≥n:

- `SubString(s, i, j)`: Devuelve la subcadena que va desde el √≠ndice `i` al √≠ndice `j`, ambos incluidos.

```julia
julia> c = "julia"
"julia"

julia> c[2:4]
"uli"

julia> SubString(c, 2, 4)
"uli"
```

---

## Concatenaci√≥n de cadenas

- `a * b`: Devuelve la cadena que resulta de concatenar las cadenas `a` y `b`.
- `a ^ i`: Devuelve la cadena que resulta de repetir la cadena `a` el n√∫mero de veces `i`.
- `repeat(a, i)`: Devuelve la cadena que resulta de repetir la cadena `a` el n√∫mero de veces `i`.

```julia
julia> a = "Hola"
"Hola"

julia> b = "Julia"
"Julia"

julia> a * b
"HolaJulia"

julia> b ^ 3
"JuliaJuliaJulia"
```

---

### Interpolaci√≥n de cadenas

En una cadena se pueden introducir variables o expresiones precedidas del s√≠mbolo `$`, de manera que al evaluarlas julia sustituye la variable o expresi√≥n por su valor. Esto es muy util para formatear salidas.

```julia
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"

julia> s = "Julia"
"Julia"

julia> "Hola $s"
"Hola Julia"
```

---

### Otras operaciones comunes con cadenas

- `length(c)`: Devuelve el n√∫mero de car√°cteres de la cadena `c`.
- `findfirst(a, c)`: Devuelve el √≠ndice de la primera ocurrencia de la cadena `a` en la cadena `c`. Si `a` no es una subcadena de `c` devuelve nada (tipo `Nothing`).
- `findlast(a, c)`: Devuelve el √≠ndice de la √∫ltima ocurrencia de la cadena `a` en la cadena `c`. Si `a` no es una subcadena de `c` devuelve nada (tipo `Nothing`).
- `findnext(a, c, i)`: Devuelve el √≠ndice de la primera ocurrencia de la cadena `a` en la cadena `c` posterior al √≠ndice `i`.
- `findprev(a, c, i)`: Devuelve el √≠ndice de la √∫ltima ocurrencia de la cadena `a` en la cadena `c` anterior al √≠ndice `i`.

---

### Otras operaciones comunes con cadenas

- `occursin(a, c)`: Devuelve `true` si la cadena `a` es una subcadena de `c`, y `false` en caso contrario.
- `contains(c, a)`: Devuelve `true` si la cadena `a` es una subcadena de `c`, y `false` en caso contrario.
- `replace(c, a => b)`: Devuelve la cadena que resulta de sustituir la cadena `a` por la `b` en la cadena `c`.
- `lowercase(c)`: Devuelve la cadena `c` en min√∫sculas.
- `uppercase(c)`: Devuelve la cadena `c` en may√∫sculas.
- `prefix(c, a)`: Devuelve `true` si la cadena `a` es un prefijo de la cadena `c`.
- `suffix(c, a)`: Devuelve `true` si la cadena `a` es un sufijo de la cadena `c`.
- `split(c, a)`: Devuelve una lista con las cadenas que resulpan de partir la cadena `c` por el delimitador `a`.

---

### Ejemplo de otras operaciones con cadenas

```julia
julia> c = "Hola Julia"
"Hola Julia"

julia> length(c)
10

julia> findfirst("a", c) 
4:4

julia> findlast("Ju", c)
6:7

julia> findlast("x", c)

julia> occursin("Julia", c)
true

julia> occursin("julia", c)
false

julia> replace(c, "a" => "o")
"Holo Julio"

julia> uppercase(c)
"HOLA JULIA"

julia> split(c, " ")
2-element Vector{SubString{String}}:
 "Hola"
 "Julia"
```

# Estructuras de control

## Condicionales

> `if` _condici√≥n 1_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo 1_  
  `elseif` _condici√≥n 2_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo 2_  
  ...  
  `else`  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo n_  
  `end`

La indentaci√≥n de los bloques de c√≥digo no es necesaria, pero es una buena pr√°ctica.

---

### Ejemplo de condicional

```julia
julia> x = -1
-1

julia> if x > 0
         signo = "positivo"
       elseif x < 0
         signo = "negativo"
       else
         signo = "nulo"
       end
"negativo"
```
---

### Operador condicional

Una forma abreviada de la estructura condicional es el operador condicional. 

> _condici√≥n_ `?` _bloque true_ `:` _bloque false_

Este operador ejecuta el primer bloque de c√≥digo si la condici√≥n es `true` y el segundo en caso contrario.

```julia
julia> x > 0 ? signo = "positivo" : signo = "negativo"
"negativo"
```

## Bucles

## Bucles iterativos

> `for` _iterador_ `in` _secuencia_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo_  
  `end`

Ejecuta el bloque de c√≥digo tantas veces como elementos tenga la _secuencia_. En cada iteraci√≥n el _iterador_ toma como valor el siguiente elemento de la _secuencia_.  

```julia
julia> c = "Julia"
"Julia"

julia> for i in c
         println(i)
       end
J
u
l
i
a
```

---

### Bucles iterativos con rangos

En muchas ocasiones la secuencia que se recorre en un bucle iterativo se genera mediante un rango, que es una secuencia de n√∫meros igualmente espaciados. Existen distintas funciones para generar rangos:

- `i:j`: Genera la secuenciad de n√∫meros desde `i` hasta `j`.
- `i:j:k`: Genera la secuencia de n√∫meros desde `i` hasta `k` dando saltos de `j`.
- `StepRange(i, j, k)`: Genera la secuencia de n√∫meros desde `i` hasta `k` dando saltos de `j`.
- `range(i, j, n)`: Genera una secuencia de `n` n√∫meros desde `i` hasta `j`.

---

### Ejemplo de bucles iterativos con rangos

```julia
julia> for i in 1:2:10
         println(i)
       end
1
3
5
7
9

julia> for i = range(0, 10, 5)
         println(i)
       end
0.0
2.5
5.0
7.5
10.0
```

---

### Bucles iterativos anidados

En muchas ocasiones es habitual incluir un bucle iterativo en el bloque de c√≥digo de otro bucle iterativo, lo que se conoce como _bucles anidados_.

Julia permite simplicar estas estructuras indicando los iteradores en la cabecera de un √∫nico bucle.

```julia
julia> for i in "abc", j = 1:2
         println(i,j)
       end
a1
a2
b1
b2
c1
c2
```

## Bucles condicionales

> `while` _condici√≥n_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo_  
  `end`

Repite la ejecuci√≥n del bloque de c√≥digo mientras que la _condici√≥n_ sea cierta.

```julia
julia> x = 3
3

julia> while x >= 0
          println(x)
          x -= 1
       end
3
2
1
0
```

---

### Interrupci√≥n de bucles

La instrucci√≥n `break` provoca inmediatamente la finalizaci√≥n de un bucle tanto iterativo como condicional.

```julia
julia> x=3
3

julia> while true
          if x < 0 
             break
          end
          println(x)
          x -= 1
       end
3
2
1
0
```

---

### Salto de bucles

La instrucci√≥n `continue` provoca la finalizaci√≥n del bloque de c√≥digo de un bucle y pasa inmediatamente a la siguiente iteraci√≥n.

```julia
julia> for i in 1:10
          if i % 2 == 0
             continue
          end
          println(i)
       end
1
3
5
7
9
```

# Tipos de datos compuestos

Colecciones de datos con distinta estructura y sem√°ntica.

- Arrays
  - Vectores
  - Matrices
- Tuplas
- Diccionarios

## Arrays 

Un **array** es una colecci√≥n ordenada de datos de un mismo tipo.

El tipo del array se infiere autom√°ticamente a partir de los tipos de sus elementos. Si los elementos son de distintos tipos se convierten al tipo m√°s espec√≠fico de la jerarqu√≠a de tipos del que los tipos de los elementos son subtipos.

Se construyen escribiendo sus elementos separados por comas, puntos y comas o espacios entre corchetes.

```julia
julia> [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> [1.0, "julia", true]
3-element Vector{Any}:
    1.0
     "julia"
 true
```

## Arrays multidimensionales

Los arrays pueden estructurar sus elementos en m√∫ltiples dimensiones. Dependiendo el n√∫mero de dimesiones tenemos distintos tipos de arrays:

![](img/arrays.png){}

---

### Funciones de arrays

- `length(A)`: Devuelve el n√∫mero de elementos del array `A`.
- `eltype(A)`: Deuvelve el tipo de los elementos del array `A`.
- `ndims(A)`: Devuelve el n√∫mero de dimensiones del array `A`.
- `size(A)`: Devuelve una tupla con los tama√±os de las dimensiones del array `A`.
- `size(A, n)`: Devuelve el tama√±o de la dimensi√≥n `n` del array `A`.
- `axes(A)`: Devuelve una tupla con los √≠ndices v√°lidos de cada dimensi√≥n del array `A`. 
- `axes(A, n)`: Devuelve un rango con los √≠ndices v√°lidos de la dimensi√≥n `n` del array `A`.
- `eachindex(A)`: Devuelve un iterador sobre los √≠ndices de los elementos del array `A`.

---

### Constructores de arrays

- `zeros(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos ceros.
- `ones(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos unos.
- `fill(a, dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos iguales `a`.
- `rand(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos n√∫meros aleatorios entre 0 y 1.
- `trues(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos `true`.
- `falses(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos `false`.

---

### Ejemplos de constructores de arrays

```julia
julia> zeros(3)  # Vector de tama√±o 3
3-element Vector{Float64}:
 0.0
 0.0
 0.0

julia> rand(3,2)  # Matriz de tama√±o 3 x 2
3√ó2 Matrix{Float64}:
 0.1469    0.891839
 0.953462  0.395681
 0.819468  0.720606

julia> fill(œÄ, 2, 2)
2√ó2 Matrix{Irrational{:œÄ}}:
 œÄ  œÄ
 œÄ  œÄ
```

---

### Redimiensionado de arrays

La siguientes funciones permiten cambiar las dimensiones de un array, reestructurando sus elementos:

- `rehape(A, dim)`: Devuelve el array que resulta de redimiensionar el array `A` con las dimensiones indicadas por la tupla `dim`.
- `permutedims(A)`: Devuelve el array de resulta de trasponer el array `A`.

:::{.callout-warning}
El array resultante debe tener los mismos elementos que el array original, por lo que si las dimensiones no son compatibles se produce un error.
:::

---

### Ejemplo de redimensionado de arrays

```julia
julia> v = [1, 2, 3, 4, 5, 6]
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6

julia> reshape(v, 2, 3)
2√ó3 Matrix{Int64}:
 1  3  5
 2  4  6

julia> reshape(v, 3, 2)
3√ó2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia> permutedims(reshape(v, 3, 2))
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6
```

---

### Comprensi√≥n de arrays

Una potente t√©cnica de creaci√≥n de arrays es la comprensi√≥n de arrays, que consiste en generar los elementos del array a partir de uno o varios iteradores.

- `[exp for i = ite]`: Devuelve el vector cuyos elementos resultan de evaluar a expresi√≥n `exp` para cada valor `i` del iterador `ite`.

- `[exp for i = ite if cond]`: Devuelve el vector cuyos elementos resultan de evaluar a expresi√≥n `exp` para cada valor `i` del iterador `ite` que cumpla la condici√≥n `cond`.

Se pueden utilizar varios iteradores para crear arrays de varias dimensiones. 

---

```julia
julia> [i^2 for i = 1:4]
4-element Vector{Int64}:
  1
  4
  9
 16

julia> [i^2 for i = 1:4 if i % 2 == 0]
2-element Vector{Int64}:
  4
 16

julia> [i+j for i = 1:2, j = 3:4]
2√ó2 Matrix{Int64}:
 4  5
 5  6
```


## Vectores

Los vectores son arrays de una dimensi√≥n.

Se construyen escribiendo sus elementos separados por comas o puntos y comas entre corchetes.

```julia
julia> v = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> length(v)
3

julia> eltype(v)
Int64

julia> ndims(v)
1

julia> size(v)
(3,)

julia> eachindex(v)
Base.OneTo(3)
```
---

### Acceso a los elementos de un vector

El acceso a los elementos de un vector es mediante _√≠ndices_. Cada elemento del vector tiene asociado un √≠ndice entero que se corresponde con su posici√≥n desde 1 hasta el n√∫mero de elementos. 

- `v[i]`: Devuelve el elemento del vector `v` con √≠ndice `i`.

:::{.callout-warning}
Si se proporciona un √≠ndice no v√°lido se produce un error.
:::

Las palabras reservadas `begin` y `end` se utilizan para referirse al primer y √∫ltimo √≠ndice de un vector.

---

### Ejemplo de acceso a los elementos de un vector

```julia
julia> v = [2, 4, 6]
3-element Vector{Int64}:
 2
 4
 6

julia> v[2]
4

julia> v[end]
6

julia> v[4]
ERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]
Stacktrace:
 [1] getindex(A::Vector{Int64}, i1::Int64)
   @ Base ./array.jl:861
 [2] top-level scope
   @ REPL[4]:1
```

---

### Acceso a m√∫ltiples elementos de un vector

Es posible extraer varios elementos de un vector a la vez indicando los √≠ndices mediante un rango o un vector de enteros.

- `v[i:j]`: Devuelve un vector con los elementos del vector `v` desde el √≠ndice `i` al `j`.
- `v[u]`: Devuelve un vector con los elementos del vector `v` correspondientes a los √≠ndices del vector `u`.

```julia
julia> v = [2, 4, 6, 8];

julia> v[2:3]
2-element Vector{Int64}:
 4
 6

julia> v[[2,4,3]]
3-element Vector{Int64}:
 4
 8
 6
```

---

### Modificaci√≥n de los elementos de un vector

Tambi√©n es posible modificar un vector asignando nuevos elementos mediante los √≠ndices.

- `v[i] = a`: A√±ade el elemento `a` al vector `v` en el √≠ndice `i`.

```julia
julia> v = [2, 4, 6]
3-element Vector{Int64}:
 2
 4
 6

julia> v[2] = 0
0

julia> v
3-element Vector{Int64}:
 2
 0
 6
```

---

### A√±adir elementos a un vector

Las siguientes funciones permiten a√±adir elementos al final de un vector:

- `push!(v, a)`: A√±ade el elemento `a` al final del vector `v`.
- `append!(v, u)`: A√±ade los elementos del vector `u` al final del vector `v`.

```julia
julia> v = [];

julia> push!(v, 1)
1-element Vector{Any}:
 1

julia> append!(v, [2, 3])
3-element Vector{Any}:
 1
 2
 3

julia> v
3-element Vector{Any}:
 1
 2
 3
```

---

### Recorrer un vector

Una operaci√≥n habitual es recorrer los elementos de un vector para hacer cualquier operaci√≥n con ellos. Existen dos posibilidades: recorrer el vector por √≠ndice o por valor.

```julia
julia> v = [2, 4, 6];

julia> for i in v  # Recorrido por valor
         println(i)
       end
2
4
6

julia> for i in eachindex(v)  # Recorrido por √≠ndice
         println(v[i])
       end
2
4
6
```

---


### Operaciones con vectores num√©ricos

- `minimum(v)`: Devuelve el menor elemento del vector `v`.
- `maximum(v)`: Devuelve el mayor elemento del vector `v`.
- `argmin(v)`: Devuelve el √≠ndice del menor elemento del vector `v`.
- `argmax(v)`: Devuelve el √≠ndice del mayor elemento del vector `v`.
- `sum(v)`: Devuelve la suma de los elementos del vector `v`.
- `prod(v)`: Devuelve el producto de los elementos del vector `v`.
- `unique(v)`: Devuelve un vector con los elementos de `v` sin repetir.

```julia
julia> v = [4, 2, 3];

julia> maximum(v)
4

julia> argmax(v)
1

julia> sum(v)
9

julia> prod(v)
24
```

---

### Ordenaci√≥n de vectores

- `sort(v, rev=true)`: Devuelve el vector que resulta de ordenar en orden ascendente los elementos del vector `v`. Si se pasa `true` al par√°metro `rev` el orden es descendente.
- `sort!(v, rev=true)`: Ordena el vector `v` en orden ascendente. Si se pasa `true` al par√°metro `rev` el orden es descendente. 
- `reverse(v)`: Devuelve el vector con los elementos del vector `v` en orden inverso.
- `reverse!(v)`: Modifica el vector `v` poniendo sus elementos en orden inverso.

---

### Ejemplo de ordenaci√≥n de vectores

```julia
julia> v = [4, 2, 3];

julia> sort(v)
3-element Vector{Int64}:
 2
 3
 4

julia> reverse(v)
3-element Vector{Int64}:
 3
 2
 4

julia> v
3-element Vector{Int64}:
 4
 2
 3

julia> reverse!(v)
3-element Vector{Int64}:
 3
 2
 4

julia> v
3-element Vector{Int64}:
 3
 2
 4
```

---

### Extensi√≥n de funciones a vectores

Si una funci√≥n recibe un par√°metro del tipo de los elementos de un vector, se puede aplicar la funci√≥n a cada uno de los elementos del vector, extendiendo la llamada de la funci√≥n sobre los elementos del vector. Para ello basta con a√±adir un punto entre el nombre de la funci√≥n y el par√©ntesis de los argumentos.

- `f.(v)`: Devuelve el vector que resulta de aplicar la funci√≥n `f` a cada uno de los elementos del vector `v`. 

:::{.callout-warning}
En la llamada a la funci√≥n hay que pasarle com argumentos tantos vectores como par√°metros tenga la funci√≥n. Si los vectores son de distinto tama√±o, se reciclan los de menor tama√±o.
:::

:::{.callout-warning}
Si la funci√≥n no devuelve ning√∫n valor el resultado es un vector de valores `nothing`.
:::

La extensi√≥n de funciones tambi√©n funciona con operadores, poniendo el punto delante del operador.

---

### Ejemplo de extensi√≥n de funciones a vectores

```julia
julia> v = [1, 4, 9];

julia> sqrt.(v)
3-element Vector{Float64}:
 1.0
 2.0
 3.0

julia> v .^ 2
3-element Vector{Int64}:
  1
 16
 81

julia> base = [2, ‚ÑØ, 10];

julia> log.(base, v)
3-element Vector{Float64}:
 0.0
 1.3862943611198906
 0.9542425094393249
```

---

### Filtrado de vectores

Otra operaci√≥n bastante com√∫n son los filtros de vectores. Se puede filtrar un vector a partir de un vector de booleanos del mismo tama√±o. 

- `v[u]`: Devuelve el vector con los elementos que tienen el mismo √≠ndice que los valores `true` del vector booleano `u`.

Esto permite aplicar filtros a partir de condiciones que devuelvan un vector de booleanos.

---

### Ejemplo de filtrado de vectores

```julia
julia> v = [1, 2, 3, 4];

julia> v[[true, false, true, false]]
2-element Vector{Int64}:
 1
 3

julia> v .% 2 .== 0  # Condici√≥n
4-element BitVector:
 0
 1
 0
 1

julia> v[v .% 2 .== 0]  # Filtro de n√∫meros pares
2-element Vector{Int64}:
 2
 4
```

---

### √Ålgebra lineal con vectores

- `u` + `v`: Devuelve el vector que resulta de la suma de los vetores `u` y `v`.
- `u` - `v`: Devuelve el vector que resulta de la resta de los vetores `u` y `v`.
- `a * v`: De vuelve el vector que resulta de multiplicar el vector `v` por el escalar `a`.
- `v'`: Devuelve el vector que resulta de trasponer el vector `v`. Si `v` es un vector fila, `v'` es un vector columna y viceversa.

Con el paquete [`LinearAlgebra`](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/) tambi√©n est√°n disponibles las siguientes funciones:

- `dot(u, v)`: Devuelve el producto escalar de los vectores `u` y `v`.
- `norm(v)`: Devuelve la norma (m√≥dulo) del vector `v`.

---

### Ejemplo de √°lgebra lineal con vectores

```julia
julia> u = [1, 2, 3]; v = [1, 0, 2];

julia> u + v
3-element Vector{Int64}:
 2
 2
 5

julia> 2u
3-element Vector{Int64}:
 2
 4
 6

julia> dot(u, v)  # Producto escalar
7

julia> u'v  # Producto escalar
7

julia> norm(v)  # Norma o m√≥dulo
2.23606797749979

julia> u / norm(u)  # Vector unitario
3-element Vector{Float64}:
 0.2672612419124244
 0.5345224838248488
 0.8017837257372732
```

## Matrices

Las matrices son arrays de dos dimensiones (filas x columnas).

Se construyen escribiendo sus elementos entre corchetes, separando los elementos por espacio y las filas por punto y coma `;`.

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> length(A)
6

julia> eltype(A)
Int64

julia> ndims(A)
2

julia> size(A)
(2, 3)
```

---

### Acceso a los elementos de una matriz

El acceso a los elementos de una matriz es mediante _√≠ndices_. Cada elemento de la matriz tiene asociado un par de √≠ndices enteros que se corresponde la fila y la columna que ocupa. 

- `A[i, j]`: Devuelve el elemento de la matriz `A` con √≠ndice de fila `i` e √≠ndice de columna `j`.

:::{.callout-warning}
Si se proporciona alg√∫n √≠ndice no v√°lido se produce un error.
:::

Tambi√©n se puede acceder a los elementos de una matriz mediante un √∫nico √≠ndice. En ese caso se obtiene el elemento con ese √≠ndice en el vector que resulta de concatenar los elementos de la matriz por columnas. 

---

### Ejemplo de acceso a los elementos de una matriz

```julia
julia> A = reshape(1:6, 2, 3)
2√ó3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6

julia> A[2, 1]
2

julia> A[4]
4
```
---

### Acceso a m√∫ltiples elementos de una matriz

Es posible extraer varios elementos de una matriz a la vez indicando los √≠ndices de las filas y las columnas mediante un rango o un vector de enteros.

- `A[i:j, k:l]`: Devuelve una matriz con los elementos desde el √≠ndice de fila `i` al `j` y el √≠ndice de columna `k` al `l` de la matriz `A`.
- `A[u, w]`: Devuelve una matriz con los elementos correspondientes a los √≠ndices de fila del vector `u` y los √≠ndices de columna del vector `w` de la matriz `A`.

---

## Ejemplo de acceso a m√∫ltiples elementos de una matriz

```julia
julia> A = reshape(1:9, 3, :)
3√ó3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:
 1  4  7
 2  5  8
 3  6  9

julia> A[1:2, 2:3]
2√ó2 Matrix{Int64}:
 4  7
 5  8

julia> A[[1, 3], [3, 1]]
2√ó2 Matrix{Int64}:
 7  1
 9  3

julia> A[2, :]  # Segundo vector fila
3-element Vector{Int64}:
 2
 5
 8
```

---

### Modificaci√≥n de los elementos de una matriz

Tambi√©n es posible modificar una matriz asignando nuevos elementos mediante los √≠ndices de fila y columna.

- `A[i, j] = a`: A√±ade el elemento `a` a la matriz `A` con el √≠ndice de fila `i` y el √≠ndice de columna `j`.

```julia
julia> A = zeros(2, 3)
2√ó3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> A[2,3] = 1
1

julia> A
2√ó3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  1.0
```

---

### Concatenaci√≥n de matrices

Dos o m√°s matrices pueden concatenarse horizontal o verticalmente siempre que sus dimensiones sean compatibles.

- `[A B]`: Devuelve la matriz que resulta de concatenar horizontalmente las matrices `A` y `B`. Ambas matrices deben tener el mismo n√∫mero de filas.
- `[A; B]`: Devuelve la matriz que resulta de concatenar verticalmente las matrices `A` y `B`. Ambas matrices deben tener el mismo n√∫mero de columnas.

---

### Ejemplo de concatenaci√≥n de matrices

```julia
julia> A = zeros(2, 2)
2√ó2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0

julia> B = ones(2, 1)
2√ó1 Matrix{Float64}:
 1.0
 1.0

julia> C = ones(1, 3)
1√ó3 Matrix{Float64}:
 1.0  1.0  1.0

julia> D = [A B]
2√ó3 Matrix{Float64}:
 0.0  0.0  1.0
 0.0  0.0  1.0

julia> [D ; C]
3√ó3 Matrix{Float64}:
 0.0  0.0  1.0
 0.0  0.0  1.0
 1.0  1.0  1.0
```

---

### Concatenaci√≥n de vectores

Tambi√©n es posible concatenar varios vectores horizontalmente o verticalmente para formar una matriz. 

- `hcat(v...)`: Devuelve la matriz que resulta de concatenar horizontalmente los vectores del vector `v`.
- `vcat(v...)`: Devuelve la matriz que resulta de concatenar verticalmente los vectores del vector `v`.

---

### Ejemplo de concatenaci√≥n de vectores

```julia
julia> v = [[1, 2, 3], [4, 5, 6]]
2-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [4, 5, 6]

julia> hcat(v...)
3√ó2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia> v = [[1 2 3], [4 5 6]]
2-element Vector{Matrix{Int64}}:
 [1 2 3]
 [4 5 6]

julia> vcat(v...)
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6
```

### Recorrido de matrices

Una operaci√≥n habitual es recorrer los elementos de una matriz para hacer una operaci√≥n con ellos. El recorrido se suele hacer con dos bucles iterativos anidados.

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> for i = 1:size(A, 1), j = 1:size(A, 2)  # Recorrido por filas
         println(A[i, j])
       end
1
2
3
4
5
6

julia> for j = 1:size(A, 2), i = 1:size(A, 1)  # Recorrido por columnas
         println(A[i, j])
       end
1
4
2
5
3
6
```

---

### Operaciones con matrices num√©ricas

- `minimum(A)`: Devuelve el menor elemento de la matriz `A`.
- `maximum(A)`: Devuelve el mayor elemento de la matriz `A`.
- `argmin(A)`: Devuelve los √≠ndices de fila y columna del menor elemento de la matriz `A`.
- `argmax(A)`: Devuelve los √≠ndices de fila y columna del mayor elemento de la matriz `A`.
- `sum(A)`: Devuelve la suma de los elementos de la matriz `A`.
- `prod(A)`: Devuelve el producto de los elementos de la matriz `A`.

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> minimum(A)
1

julia> argmax(A)
CartesianIndex(2, 3)

julia> sum(A)
21

julia> prod(A)
720
```

---

### Extensi√≥n de funciones a matrices

Al igual que para vectores, se puede aplicar una una funci√≥n a todos los elementos de una matriz. Para ello basta con a√±adir un punto entre el nombre de la funci√≥n y el par√©ntesis de los argumentos.

- `f.(A)`: Devuelve la matriz que resulta de aplicar la funci√≥n `f` a cada uno de los elementos de la matriz `A`. 

:::{.callout-warning}
En la llamada a la funci√≥n hay que pasarle com argumentos tantos vectores como par√°metros tenga la funci√≥n. Si las matrices son de distinto tama√±o, se reciclan las de menor tama√±o.
:::

La extensi√≥n de funciones tambi√©n funciona con operadores, poniendo el punto delante del operador.

---

### Ejemplo de extensi√≥n de funciones a matrices

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> sqrt.(A)
2√ó3 Matrix{Float64}:
 1.0  1.41421  1.73205
 2.0  2.23607  2.44949

julia> A .+ 1
2√ó3 Matrix{Int64}:
 2  3  4
 5  6  7
```

---

### √Ålgebra lineal con matrices

- `A` + `B`: Devuelve la matriz que resulta de la suma de las matrices `A` y `B`. Ambas matrices deben tener las mismas dimensiones.
- `A` - `B`: Devuelve la matriz que resulta de la resta de las matrices `A` y `B`. Ambas matrices deben tener las mismas dimensiones.
- `a * A`: Devuelve la matriz que resulta de multiplicar la matriz `A` por el escalar `a`.
- `A * B`: Devuelve la matriz producto de las matrices `A` y `B`. El n√∫mero de columnas de `A` debe coincidir con el n√∫mero de filas de `B`.
- `A'`: Devuelve la matriz traspuesta de la matriz `A`.
- `transpose(A)`: Devuelve la matriz traspuesta de la matriz `A`.

---

### Ejemplo de √°lgebra lineal con matrices

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> B = [1 1 1; 2 2 2]
2√ó3 Matrix{Int64}:
 1  1  1
 2  2  2

julia> A + B
2√ó3 Matrix{Int64}:
 2  3  4
 6  7  8

julia> C = A'
3√ó2 adjoint(::Matrix{Int64}) with eltype Int64:
 1  4
 2  5
 3  6

julia> A * C
2√ó2 Matrix{Int64}:
 14  32
 32  77

julia> C * A
3√ó3 Matrix{Int64}:
 17  22  27
 22  29  36
 27  36  45

```

### √Ålgebra lineal con matrices

El paquete [`LinearAlgebra`](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/) define las siguientes funciones:

- `Matrix(I, n, n)`. Devuelve la matriz identidad de dimensi√≥n `n`.
- `diag(A)`: Devuelve un vector con los elementos de la diagonal principal de la matriz `A`.
- `norm(A)`: Devuelve la norma de Frobenius de la matriz `A`.
- `tr(A)`: Devuelve la traza de la matriz cuadrada `A`.
- `det(A)`: Devuelve el determinante de la matriz cuadrada `A`.
- `inv(A)`: Devuelve la matriz inversa de la matriz cuadrada `A`.
- `A \ B`: Devuelve el vector `x` soluci√≥n del sistema de ecuaciones $Ax = B$, donde `A` es una matriz cuadrada y `B` es un vector del mismo tama√±o que el n√∫mero de filas o columnas de `A`.

---

### Ejemplo de √°lgebra lineal con matrices

```julia
julia> Matrix(I, 3, 3)
3√ó3 Matrix{Bool}:
 1  0  0
 0  1  0
 0  0  1

julia> A = [1 2 3; 0 1 0; 1 0 1]
3√ó3 Matrix{Int64}:
 1  2  3
 0  1  0
 1  0  1

julia> diag(A)
3-element Vector{Int64}:
 1
 1
 1

julia> norm(A)
4.123105625617661

julia> tr(A)
3

julia> det(A)
-2.0

julia> inv(A)
3√ó3 Matrix{Float64}:
 -0.5   1.0   1.5
  0.0   1.0   0.0
  0.5  -1.0  -0.5

julia> B = [10, 2, 4]
3-element Vector{Int64}:
 10
  2
  4

julia> A \ B  # Soluci√≥n del sistema Ax = B
3-element Vector{Float64}:
 3.0
 2.0
 1.0
```

---

### √Ålgebra lineal con matrices

Otras funciones m√°s avanzadas del paque `LinearAlgebra` son:

- `eigvals(A)`: Devuelve un vector con los autovalores de la matriz `A`. 
- `eigvecs(A)`: Devuelve la matriz con los autovectore de la matriz `A`.
- `factorize(A)`: Devuelve las matrices resultantes de la factorizaci√≥n de la matriz `A`. La factorizaci√≥n depender√° de las propiedades de `A` (ver [tipos de factorizaci√≥n](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#man-linalg-factorizations))

---

### Ejemplos de √Ålgebra lineal con matrices

```julia
julia> A = [1 2; 3 1]
2√ó2 Matrix{Int64}:
 1  2
 3  1

julia> eigvals(A)
2-element Vector{Float64}:
 -1.4494897427831779
  3.4494897427831783

julia> eigvecs(A)
2√ó2 Matrix{Float64}:
 -0.632456  0.632456
  0.774597  0.774597

julia> B = [1 2; 2 1]
2√ó2 Matrix{Int64}:
 1  2
 2  1

julia> factorize(B)
LU{Float64, Tridiagonal{Float64, Vector{Float64}}}
L factor:
2√ó2 Matrix{Float64}:
 1.0  0.0
 0.5  1.0
U factor:
2√ó2 Matrix{Float64}:
 2.0  1.0
 0.0  1.5
```

---

### Copia de tipos de datos compuestas

En Julia cuando se asigna una variable de un tipo de datos compuesto a otra variable, no se hace una copia de la estructura de datos referenciada por la primera variable, sino que se la nueva variable apunta a la misma direcci√≥n de memoria de la estructura de datos (copia por referencia). El resultado son dos variables que apuntan a la misma estructura de datos y cualquier cambio en una de ellas se ver√° reflejado en la otra. 

Para hacer copias por valor de un tipo de datos compuesto debe usarse expl√≠citamente la siguiente funci√≥n:

- `b = copy(a)`: Crea una copia de la estructura de datos referencia por `a` y asigna su referencia a `b`.

---

### Ejemplo de copia de tipos de datos compuestos

```julia
julia> v = [1, 2, 3];

julia> u = copy(v);  # Copia por valor

julia> u[2] = 0;

julia> u
3-element Vector{Int64}:
 1
 0
 3

julia> v
3-element Vector{Int64}:
 1
 2
 3

julia> u = v;  # Copia por referencia

julia> u[2]=0;

julia> v
3-element Vector{Int64}:
 1
 0
 3
```

## Tuplas

Una tupla es una colecci√≥n ordenada de tama√±o fijo que puede contenere elementos de distintos tipos. 

Generalmente se usan para pasar par√°metros o devolver valores de funciones.

Se crean escribiendo sus elementos separados por comas entre par√©ntesis.

:::{.callout-warning}
Las tuplas son inmutables, es decir, una vez creadas no pueden cambiarse sus elementos.
:::

```julia
julia> ()  # Tupla vac√≠a
()

julia> (1, "enero", 2020) 
(1, "enero", 2020)

julia> t = (1, "enero", 2020)
(1, "enero", 2020)

julia> typeof(t)
Tuple{Int64, String, Int64}
```

---

### Tuplas con nombres

Es posible asignar un nombre a cada uno de los elementos de la tupla. Para ello cada elemento de la tupla con nombre debe escribirse con la sintaxis `nombre = valor`.

```julia
ulia> t = (d√≠a = 1, mes = "enero", a√±o =  2020)
(d√≠a = 1, mes = "enero", a√±o = 2020)

julia> typeof(t)
NamedTuple{(:d√≠a, :mes, :a√±o), Tuple{Int64, String, Int64}}
```

:::{.callout-warning}
No puede haber dos elementos con el mismo nombre en una tupla.
:::

La ventaja de usar tuplas con nombres es que podemos acceder a sus elementos por nombre, adem√°s de por √≠ndice.

---

### Acceso a los elementos de una tupla

Como las tuplas tienen orden, podemos acceder a sus elementos mediante √≠ndices, al igual que con los arrays de una dimensi√≥n. 

- `t[i]`: Devuelve el elemento con √≠ncide `i` de la tupla `t`.

Si la tupla tiene nombres tambi√©n es posible acceder a sus elementos mediante los nombres.

- `t.x`: Devuelve el elemento con nombre `x` de la tupla `t`.

```julia
julia> t = (d√≠a = 1, mes = "enero", a√±o =  2020)
(d√≠a = 1, mes = "enero", a√±o = 2020)

julia> t[2]
"enero"

julia> t.a√±o
2020

julia> 
```

---

### Asignaci√≥n m√∫ltiple de tuplas

Es posible asignar los elementos de una tupla a distintas variables en una sola asignaci√≥n.

`x, y, ... = t`: Asigna a las variables `x`, `y`, etc los elementos de la tupla `t` en orden. Si el n√∫mero de variables es menor que el tama√±o de la tupla, los √∫ltimos elementos quedan sin asignar.

`x, y... = t`: Asigna el primer elemento de la tupla `t` a la variable `x` y la tupla con los elementos restantes a la variable `y`.

---

### Ejemplo de asignaci√≥n m√∫ltipe de tuplas

```julia
julia> t = (1, "enero", 2020)
(1, "enero", 2020)

julia> d, m, a = t
(1, "enero", 2020)

julia> d
1

julia> m
"enero"

julia> a
2020

julia> d, ma... = t 
(1, "enero", 2020)

julia> d
1

julia> ma
("enero", 2020)
```

## Diccionarios

Un diccionario es una colecci√≥n asociativa sin orden cuyos elementos son pares formados por una _clave_ y un _valor_ asociado a la clave. 

Se parecen a las tuplas con nombre, pero, a diferencia de estas, son mutables, es decir, su contenido se puede alterar.

Se construyen con la siguiente funci√≥n:

- `Dic(k1 = v1, ...)`: Crea un diccionario con los pares indicados en formato `clave = valor`.

:::{.callout-warning}
En un diccionario no pueden existir dos pares con la misma clave, de modo que si se repite una clave se sobreescribe el par anterior.
:::

---

### Ejemplo de diccionarios

```julia
julia> Dict()  # Diccionario vac√≠o
Dict{Any, Any}()

julia> d = Dict("ES" => "Euro", "US" => "Dollar", "CN" => "Yuan")
Dict{String, String} with 3 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "US" => "Dollar"

julia> typeof(d)
Dict{String, String}
```

---

### Acceso a los elementos de un diccionario

Para acceder a los valores de un diccionario se utilizan sus claves asociadas entre corchetes.

- `d[k]`: Devuelve el valor asociado a la clave `k` en el diccionario `d`.

:::{.callout-warning}
Si la clave no existe en el diccionario se produce un error.
:::

Para evitar errores es conveniente usar alguna de las siguientes funciones:

- `haskey(d, k)`: Devuelve `true` la clave `k` est√° en diccionario `d` y `false` en caso contrario.
- `get(d, k, v)`: Devuelve el valor asociado a la clave `k` en el diccionario `d` o el valor `v` si la clave `k` no existe.
- `get!(d, k, v)`: Devuelve el valor asociado a la clave `k` en el diccionario `d`. Si la clave `k` no existe en el diccionario `d` a√±ade el par con la clave `k` y el valor `v` y devuelve el valor `v`.

---

### Ejemplo de acceso a los elementos de un diccionario

```julia
julia> d = Dict("ES" => "Euro", "US" => "Dollar", "CN" => "Yuan")
Dict{String, String} with 3 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "US" => "Dollar"

julia> d["ES"]
"Euro"

julia> d["JP"]
ERROR: KeyError: key "JP" not found
Stacktrace:
 [1] getindex(h::Dict{String, String}, key::String)
   @ Base ./dict.jl:481
 [2] top-level scope
   @ REPL[22]:1

julia> get(d, "JP", "Dollar")
"Dollar"

julia> get!(d, "JP", "Yen")
"Yen"

julia> d
Dict{String, String} with 4 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "JP" => "Yen"
  "US" => "Dollar"
```

---

### Recorrido de las claves y valores de un diccionario

Las siguientes funciones permiten obtener todas las claves, valores y pares de un diccionario.

- `keys(d)`: Devuelve un iterador con las claves del diccionario `d`.
- `values(d)`: Devuelve un iterador con las claves del diccionario `d`.

Estos iteradores permiten recorrer facilmente los pares de un diccionario.

---

### Ejemplo de recorrido de las claves y valores de un diccionario

```julia
julia> d = Dict("ES" => "Euro", "US" => "Dollar", "CN" => "Yuan")
Dict{String, String} with 3 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "US" => "Dollar"

julia> keys(d)
KeySet for a Dict{String, String} with 3 entries. Keys:
  "CN"
  "ES"
  "US"

julia> values(d)
ValueIterator for a Dict{String, String} with 3 entries. Values:
  "Yuan"
  "Euro"
  "Dollar"

julia> for k = keys(d)
         println("$k = $(d[k])")
       end
CN = Yuan
ES = Euro
US = Dollar

julia> for (k, v) = d
       println("$k = $v")
       end
CN = Yuan
ES = Euro
US = Dollar
```

---

### A√±adir elementos a un diccionario

Se pueden a√±adir pares nuevos a un diccionario de la siguiente manera:

- `d[k] = v`: A√±ade el par con clave `k` y valor `v` al diccionario `d`. Si la clave `k` ya exist√≠a en el diccionario `d`, cambia su valor asociaco por `v`.

- `push!(d, k => v)`: A√±ade el par con clave `k` y valor asociado `v` al diccionario `d`.

```julia
julia> d = Dict("ES" => "Euro", "US" => "Dollar")
Dict{String, String} with 2 entries:
  "ES" => "Euro"
  "US" => "Dollar"

julia> d["CN"] = "Yuan"
"Yuan"

julia> push!(d, "JP" => "Yen")
Dict{String, String} with 4 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "JP" => "Yen"
  "US" => "Dollar"
```