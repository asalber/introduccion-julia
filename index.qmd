---
title: "Introducci√≥n a Julia"
subtitle: "Orientada a computaci√≥n cient√≠fica y an√°lisis de datos"
author: "Alfredo S√°nchez Alberca<br>[asalber@ceu.es](mailto:asalber@ceu.es)<br>[https://aprendeconalf.es](https://aprendeconalf.es)"
format: 
    revealjs:
        theme: [dark, custom.scss]
        logo: img/logos/logo-julia.svg
        navigation-mode: vertical
        footer: <https://aprendeconalf.es/introduccion-julia>
        code-line-numbers: false
        code-tools:
            code-block-bg: true
            code-block-border-Izquierda: "#31BAE9"
        highlight-style: monokai
        callout-appearance: simple
execute: 
  echo: true
---

# Introducci√≥n a Julia

## ¬øPor qu√© Julia?

[Julia](https://julialang.org/) es otro lenguaje de programaci√≥n m√°s, orientado a c√°lculo cient√≠fico el an√°lisis de datos similar a Python, R o Matlab.

::: {.fragment .r-stack}
_¬øDe veras necesitamos aprender otro lenguaje m√°s?_
:::

## ¬øQu√© pretende ser Julia?

De los creadores de Julia:

>_We want a language that is:_
>
- _Open source._
- _With the speed of C._
- _Obvious, familiar mathematical notation like Matlab._
- _As usable for general programming as Python._
- _As easy for statistics as R._
- _As natural for string processing as Perl._
- _As powerful for linear algebra as Matlab._
- _As good at gluing programs together as the shell._
- _Dirt simple to learn, yet keeps the most serious hackers happy._

## ¬øQu√© es Julia?

- Julia es un lenguaje de alto nivel con una sintaxis f√°cil de aprender (similar a Python, R o Matlab) que permite escribir s√≠mbolos matem√°ticos en las expresiones (UTF-8).
- Julia es un lenguaje muy veloz (equiparable a C en muchas tareas.)
- Lenguaje din√°mico (tipado din√°mico y despacho m√∫ltiple).
- De prop√≥sito general, pero orientado a la computaci√≥n cient√≠fica y el an√°lisis de grandes vol√∫menes de datos.
- Creado en 2019 en el MIT por el equipo del profesor Edelman.
- √öltima versi√≥n: 1.7 (bastante maduro).
- Desarrollado por una gran [comunidad cient√≠fica](https://julialang.org/community/).
- [Repositorio de paquetes](https://julialang.org/packages/) de c√≥digo abierto con m√°s de 3000 paquetes en dominios muy diversos.

---

### Comparativa de rapidez de Julia con otros lenguajes

![Comparativa de Julia con otros lenguajes](./img/benchmarks.svg)

## Algunas razones m√°s para pens√°rselo

- Evita el problema de la doble reescritura de c√≥digo (prototipo + versi√≥n operativa).
- Permite la programaci√≥n paralela y distribuida.
- Puede ejecutar c√≥digo realizado en otros lenguajes como C, Fortran, Python, R, Matlab, etc.

## Instalaci√≥n de Julia

1. [Descargar e instalar Julia](https://julialang.org/downloads/).
2. A√±adir Julia al PATH del sistema.

Una vez instalado, para ejecutar el int√©rprete de Julia basta con abrir una terminal y teclear `julia`.

```bash
prompt> julia
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.7.3 (2022-05-06)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia> 
```

## El REPL de Julia

El REPL^[Read, Evaluate, Print and Loop] de Julia permite ejecutar c√≥digo de Julia tecle√°ndolo directamente en la terminal. 

```bash
julia> 2 + 3
5
```

Tiene, adem√°s, varios modos:

- `;` para abrir el modo shell.
- `]` para abrir el modo de gesti√≥n de paquetes.
- `?` para abrir el modoe de ayuda.to open help mode
- `<backspace>` para volver al modo normal.


## IDEs para Julia

![](img/julia-ides.png)

---

### [Visual studio code](https://code.visualstudio.com/)

- [Descargar e instalar VSCode](https://code.visualstudio.com/Download).
- [Instalar la extensi√≥n de Julia](https://www.julia-vscode.org/).

---

![Visual Studio Code con la extensi√≥n para Julia](img/vscode.png)

---

### [Jupyter](https://jupyter.org/)

- [Descargar e instalar Python](https://www.python.org/downloads/)
- [Descargar e instalar Jupyter](https://jupyter.org/install)
- Instalar el paquete IJulia:
```julia
julia> using Pkg
julia> Pkg.add("IJulia")
```
---

![Jupyter con el kernel de Julia](img/jupyter.png)

# Tipos de datos y variables

## Tipos de datos num√©ricos

- Enteros: `Int64` (64 bits por defecto).
- Racionales: `Rational{Int64}`. Utilizando el operador `//`.
- Reales: `Float64` (64 bits por defecto).
- Complejos: `Complex{Int64}`. Utilizando `im` despu√©s de la parte imaginaria.

Para averiguar el tipo de un dato se utiliza la funci√≥n `typeof()`.

---

## Ejemplos de tipos de datos num√©ricos

```julia
julia> typeof(3)
Int64

julia> typeof(3/2)
Float64

julia> typeof(3//2)
Rational{Int64}

julia> typeof(œÄ)
Irrational{:œÄ}

julia> typeof(3+2im)
Complex{Int64}
```

## Jerarqu√≠a de tipos de datos num√©ricos

![](img/tipos-datos-numericos.png)

## Constantes predefinidas

| S√≠mbolo | Descripci√≥n           |
|:---------- |:-------------- |
| `pi` o `œÄ`    | N√∫mero irracional $\pi$                   |
| `‚ÑØ` (\\euler + TAB)    | N√∫mero irracional $e$                    |
| `Inf`    | Infinito                 |
| `NaN`    | Valor no num√©rico                       |
| `Missing`    | Valor desconocido         |

---

## Ejemplo de constantes predefinidas

```julia
julia> œÄ
œÄ = 3.1415926535897...

julia> 1 / 0
Inf

julia> 0 / 0
NaN

julia> Inf + Inf
Inf

julia> Inf - Inf
NaN

julia> 0 * Inf
NaN
```

## Tipos de datos alfanum√©ricos

- car√°cteres: `Char`. Se representan entre comillas simples.
- Cadenas: `String`. Se representan entre comillas dobles.

```julia
julia> typeof('a')
Char

julia> typeof("julia")
String

julia> typeof("a")
String
```

## Tipo de datos booleanos

- Booleanos: `bool`. Son un subtipo de los enteros `Integer`.

Solo contienen dos posibles valores: `true` (1) y `false` (0).

```julia
julia> typeof(true)
Bool

julia> typeof(false)
Bool

julia> typeof(1 < 2)
Bool

julia> true + true
2
```

## Variables

Como lenguaje de tipado din√°mico, no es necesario declarar una variable antes de usarla. Su tipo se infiere directamente del valor asociado.

```julia
julia> x = 1
1

julia> typeof(x)
Int64

julia> x = "julia"
"julia"

julia> typeof(x)
String
```

No obstante, para variables de √°mbito local, por ejemplo en funciones, es posible fijar el tipo de una variable indic√°ndolo detras de su nombre con el operador `::`.

```julia
x::Int64
```

<!-- TODO: ## Conversi√≥n de tipos -->

## Nombres de variables

Julia reconoce la codificaci√≥n Unicode (UTF-8), lo que permite utilizar caracteres con tildes, letras griegas, s√≠mbolos matem√°ticos y hasta emoticonos en los nombres de variables o funciones. Para ello se utilizan [c√≥digos especiales](https://docs.julialang.org/en/v1/manual/unicode-input/) (en muchos casos son los mismos que en $\LaTeX$), pulsando despu√©s la tecla de tabulaci√≥n.

```julia
julia> Œ± = 1
1

julia> Œ≤ = 2
2

julia> Œ± + Œ≤
3

julia> üòÑ = "julia"
"julia"
```

Distingue entre may√∫sculas y min√∫sculas.

## Operadores aritm√©ticos

| Operador | Descripci√≥n           |
|:---------- |:-------------- |
| `x + y`    | Suma                       |
| `x - y`    | Resta                    |
| `x * y`    | Producto                 |
| `x / y`    | Divisi√≥n                       |
| `x √∑ y`    | Cociente divisi√≥n entera          |
| `x % y`    | Resto divisi√≥n entera                |
| `x ^ y`    | Potencia           |

## Operadores de comparaci√≥n

| Operador                   | Descripci√≥n                     |
|:---------------------------- |:------------------------ |
| `==`                 | Igualdad                 |
| `!=`, `‚â†` | Desigualdad               |
| `<`                  | Menor que                |
| `<=`, `‚â§` | Menor o igual que    |
| `>`                  | Mayor que             |
| `>=`, `‚â•` | Mayor o igual que |

## Operadores booleanos

| Operador | Descripci√≥n |
|:---------- |:------------------------------|
| `!x` | Negaci√≥n             |
| `x && y`   | Conjunci√≥n (y)|
| `x || y` | Disyunci√≥n (o)  |

## Funciones num√©ricas predefinidas

### Funciones de redondeo

| Funci√≥n         | Descripci√≥n                        |
|:--------------------- |:-----------------------------|
| `round(x)`    | Devuelve el entero m√°s pr√≥ximo a `x` |
| `round(x, digits = n)`    | Devuelve al valor m√°s pr√≥ximo a `x` con `n` decimales |
| `floor(x)`    | Redondea `x` al pr√≥ximo entero menor |
| `ceil(x)`     | Redondea `x` al pr√≥ximo entero mayor |
| `trunc(x)`    | Devuelve la parte entera de `x`      |

---

### Ejemplo de funciones de redondeo

```julia
julia> round(2.7)
3.0

julia> floor(2.7)
2.0

julia> floor(-2.7)
-3.0

julia> ceil(2.7)
3.0

julia> ceil(-2.7)
-2.0

julia> trunc(2.7)
2.0

julia> trunc(-2.7)
-2.0

julia> round(2.5)
2.0

julia> round(2.786, digits = 2)
2.79
```

---

### Funciones de divisi√≥n

| Funci√≥n                  | Descripci√≥n                                                                                               |
|:------------------------- |:--------------------------------------------------------------------------------------------------------- |
| `div(x,y)`, `x√∑y` | Cociente de la divisi√≥n entera                                                         |
| `fld(x,y)`        | Cociente de la divisi√≥n entera redondeado hacia abajo               |
| `cld(x,y)`        | Cociente de la divisi√≥n entera redondeado hacia arriba                                                         |
| `rem(x,y)`, `x%y` | Resto de la divisi√≥n entera. Se cumple `x == div(x,y)*y + rem(x,y)`                                       |
| `mod(x,y)`        | M√≥dulo con respecto a `y`. Se cumple `x == fld(x,y)*y + mod(x,y)`                                        |
| `gcd(x,y...)`    | M√°ximo com√∫n divisor positivo de `x`, `y`,...                                                          |
| `lcm(x,y...)`   | M√≠nimo com√∫n m√∫ltiplo positivo de `x`, `y`,...                                                            |

---

### Ejemplo de funciones de divisi√≥n

```julia
julia> div(5,3)
1

julia> cld(5,3)
2

julia> 5%3
2

julia> -5%3
-2

julia> mod(5,3)
2

julia> mod(-5,3)
1

julia> gcd(12,18)
6

julia> lcm(12,18)
36
```

---

### Funciones para el signo y el valor absoluto

| Funci√≥n                | Descripci√≥n                                                |
|:----------------------- |:---------------------------------------------------------- |
| `abs(x)`        | Valor absoluto de `x`                 |
| `sign(x)`       | Devuelve -1 si `x` es positivo, -1 si es negativo y 0 si es 0.       |

```julia
julia> abs(2.5)
2.5

julia> abs(-2.5)
2.5

julia> sign(-2.5)
-1.0

julia> sign(0)
0

julia> sign(2.5)
1.0
```

---

### Ra√≠ces, exponenciales y logaritmos

| Funci√≥n                | Descripci√≥n                                                                |
|:------------------------ |:-------------------------------------------------------------------------- |
| `sqrt(x)`, `‚àöx`  | Ra√≠z cuadrada de `x`                                                         |
| `cbrt(x)`, `‚àõx`  | Ra√≠z c√∫bica de `x`                                                           |
| `exp(x)`         | Exponencial de `x`                                        |
| `log(x)`         | Logaritmo neperiano de `x`                                                   |
| `log(b,x)`       | Logaritmo en base `b` de `x`                                                  |
| `log2(x)`        | Logaritmo en base 2 de `x`                                                    |
| `log10(x)`       | Logaritmo en base 10 de `x`                                                   |

---

### Ejemplo de ra√≠ces, exponenciales y logaritmos

```julia
julia> sqrt(4)
2.0

julia> cbrt(27)
3.0

julia> exp(1)
2.718281828459045

julia> exp(-Inf)
0.0

julia> log(1)
0.0

julia> log(0)
-Inf

julia> log(-1)
ERROR: DomainError with -1.0:
log will only return a complex result if called with a complex argument.
...

julia> log(-1+0im)
0.0 + 3.141592653589793im

julia> log2(2^3)
3.0
```

---

### Funciones trigonom√©tricas

| Funci√≥n                | Descripci√≥n                                                                |
|:------------------------ |:-------------------------------------------------------------------------- |
| `hypot(x,y)`     | Hipotenusa del tri√°ngulo rect√°ngulo con catetos `x` e `y` |
| `sin(x)`  | Seno del √°ngulo `x` en radianes                                                        |
| `sind(x)`  | Seno del √°ngulo `x` en grados                                                          |
| `cos(x)`         | Coseno del √°ngulo `x` en radianes                                       |
| `cosd(x)`         | Coseno del √°ngulo `x` en grados                                                  |
| `tan(x)`       | Tangente del √°ngulo `x` en radianes                                                  |
| `tand(x)`       | Tangente del √°ngulo `x` en grados                                                  |
| `sec(x)`        | Secante del √°ngulo `x` en radianes                                                 |
| `csc(x)`        | Cosecante del √°ngulo `x` en radianes                                                 |
| `cot(x)`       | Cotangente del √°ngulo `x` en radianes                                                  |

---

### Ejemplo de funciones trigonom√©tricas

```julia
julia> sin(œÄ/2)
1.0

julia> cos(œÄ/2)
6.123233995736766e-17

julia> cosd(90)
0.0

julia> tan(œÄ/4)
0.9999999999999999

julia> tand(45)
1.0

julia> tan(œÄ/2)
1.633123935319537e16

julia> tand(90)
Inf

julia> sin(œÄ/4)^2 + cos(œÄ/4)^2
1.0
```

---

### Funciones trigonom√©tricas inversas

| Funci√≥n                | Descripci√≥n                                                                |
|:------------------------ |:-------------------------------------------------------------------------- |
| `asin(x)`        | Arcoseno (inversa del seno) de `x` en radianes                                                 |
| `asind(x)`        | Arcoseno (inversa del seno) de `x` en grados                                                 |
| `acos(x)`       | Arcocoseno (inversa del coseno) de `x` en radianes                                                  |
| `acosd(x)`       | Arcocoseno (inversa del coseno) de `x` en grados                                                  |
| `atan(x)` | Arcotangente (inversa de la tangente) de `x` en radianes |
| `atand(x)` | Arcotangente (inversa de la tangente) de `x` en grados |
| `asec(x)` | Arcosecante (inversa de la secante) de `x` en radianes |
| `acsc(x)` | Arcocosecante (inversa de la cosecante) de `x` en radianes |
| `acot(x)` | Arcocotangente (inversa de la cotangente) de `x` en radianes |

---

### Ejemplo de funciones trigonom√©tricas inversas

```julia
julia> asin(1)
1.5707963267948966

julia> asind(1)
90.0

julia> acos(-1)
3.141592653589793

julia> atan(1)
0.7853981633974483

julia> atand(tan(œÄ/4))
45.0
```

## Precedencia de operadores

De mayor a menor prioridad.

| Categor√≠a       | Operadores                                                                                      | Asociatividad              |
|:-------------- |:------------------------------------------------------------------------------------------------- |:-------------------------- |
| Exponenciaci√≥n | `^`                                                                                               | Derecha                      |
| Unarios          | `+ - ‚àö`                                                                                           | Derecha                |
| Fracciones     | `//`                                                                                              | Izquierda                       |
| Multiplicaci√≥n | `* / % & \ √∑`                                                                                     | Izquierda                |
| Adici√≥n       | `+ - |` | Izquierda  |
| Comparaciones    | `> < >= <= == != !==`                                                                      |            |
| Asignaciones    | `= += -= *= /= //= ^= √∑= %= |= &=`                                            | Derecha                      |

## Operaciones con cadenas

Las cadenas son secuencias de car√°cteres alfanum√©ricos del tipo `char` entre dobles comillas.

Cada car√°cter tiene asociado un √≠ndice entero. El primer car√°cter de la cadena tiene √≠ndice 1. 

| | | | | | |
|:-|:-:|:-:|:-:|:-:|:-:|
|√çndice | 1 | 2 | 3 | 4 | 5 |
|Cadena | j | u | l | i | a |

Podemos acceder a cada car√°cter usando su √≠ndice entre corchetes a continuaci√≥n de la cadena:

- `s[i]`: Devuelve el car√°cter con √≠ndice `i` en la cadena `s`.

```julia
julia> c = "julia"
"julia"

julia> c[2]
'u': ASCII/Unicode U+0075 (category Ll: Letter, lowercase)
```

---

### Acceso a car√°cteres Unicode

Sin embargo, como Julia permite car√°cteres [Unicode](https://en.wikipedia.org/wiki/List_of_Unicode_characters), el √≠ndice de un car√°cter en una cadena, no siempre se corresponde con su posici√≥n en la cadena. Ello es debido a que la codificaci√≥n UTF-8 no utiliza el mismo n√∫mero de bytes para representar los car√°cteres Unicode. Mientras que los car√°cteres habituales del c√≥digo ASCII (letras romanas y n√∫meros √°rabes) solo necesitan un byte, otros car√°cteres como los s√≠mbolos matem√°ticos requieren m√°s.

| | | | | | |
|:-|:-:|:-:|:-:|:-:|:-:|
|√çndice | 1 | 4 | 5 | 6 | 9 |
|Cadena | ‚àÄ | x |   | ‚àÉ | y |

---

### Ejemplo de acceso a car√°cteres Unicode

```julia
julia> c = "‚àÄx ‚àÉy"
"‚àÄx ‚àÉy"

julia> c[1]
'‚àÄ': Unicode U+2200 (category Sm: Symbol, math)

julia> c[2]
ERROR: StringIndexError: invalid index [2], 
valid nearby indices [1]=>'‚àÄ', [4]=>'x'
Stacktrace:
 [1] string_index_err(s::String, i::Int64)
   @ Base ./strings/string.jl:12
 [2] getindex_continued(s::String, i::Int64, u::UInt32)
   @ Base ./strings/string.jl:233
 [3] getindex(s::String, i::Int64)
   @ Base ./strings/string.jl:226
 [4] top-level scope
   @ REPL[128]:1
```

---

### Acceso a √≠ndices en cadenas

Las siguientes funciones permiten acceder a los √≠ndices de una cadena:

- `firsindex(c)`: Devuelve el √≠ndice del primer car√°cter de la cadena `c`.
- `lastindex(c)`: Devuelve el √≠ndice del primer car√°cter de la cadena `c`.
- `nextind(c, i)`: Devuelve el √≠ndice del car√°cter de la cadena `c` que sigue al car√°cter con √≠ndice `i`.
- `prevind(c, i)`: Devuelve el √≠ndice del car√°cter de la cadena `c` que sigue al car√°cter con √≠ndice `i`.

---

### Ejemplo de acceso a √≠ndices en cadenas

```julia
julia> firstindex(c)
1

julia> lastindex(c)
9

julia> c[9]
'y': ASCII/Unicode U+0079 (category Ll: Letter, lowercase)

julia> nextind(c,1)
4

julia> prevind(c, lastindex(c))
6
```

---

### Subcadenas

Para obtener subcadenas se usan tambi√©n los corchetes indicando los √≠ndices de inicio y fin separados por `:`.

- `s[i:j]`: Devuelve la subcadena que va desde el √≠ndice `i` al √≠ndice `j`, ambos incluidos.

Tambi√©n se pueden obtener subcadenas con la siguiente funci√≥n:

- `SubString(s, i, j)`: Devuelve la subcadena que va desde el √≠ndice `i` al √≠ndice `j`, ambos incluidos.

```julia
julia> c = "julia"
"julia"

julia> c[2:4]
"uli"

julia> SubString(c, 2, 4)
"uli"
```

---

## Concatenaci√≥n de cadenas

- `a * b`: Devuelve la cadena que resulta de concatenar las cadenas `a` y `b`.
- `a ^ i`: Devuelve la cadena que resulta de repetir la cadena `a` el n√∫mero de veces `i`.
- `repeat(a, i)`: Devuelve la cadena que resulta de repetir la cadena `a` el n√∫mero de veces `i`.

```julia
julia> a = "Hola"
"Hola"

julia> b = "Julia"
"Julia"

julia> a * b
"HolaJulia"

julia> b ^ 3
"JuliaJuliaJulia"
```

---

### Interpolaci√≥n de cadenas

En una cadena se pueden introducir variables o expresiones precedidas del s√≠mbolo `$`, de manera que al evaluarlas julia sustituye la variable o expresi√≥n por su valor. Esto es muy util para formatear salidas.

```julia
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"

julia> s = "Julia"
"Julia"

julia> "Hola $s"
"Hola Julia"
```

---

### Otras operaciones comunes con cadenas

- `length(c)`: Devuelve el n√∫mero de car√°cteres de la cadena `c`.
- `findfirst(a, c)`: Devuelve el √≠ndice de la primera ocurrencia de la cadena `a` en la cadena `c`. Si `a` no es una subcadena de `c` devuelve nada (tipo `Nothing`).
- `findlast(a, c)`: Devuelve el √≠ndice de la √∫ltima ocurrencia de la cadena `a` en la cadena `c`. Si `a` no es una subcadena de `c` devuelve nada (tipo `Nothing`).
- `findnext(a, c, i)`: Devuelve el √≠ndice de la primera ocurrencia de la cadena `a` en la cadena `c` posterior al √≠ndice `i`.
- `findprev(a, c, i)`: Devuelve el √≠ndice de la √∫ltima ocurrencia de la cadena `a` en la cadena `c` anterior al √≠ndice `i`.

---

### Otras operaciones comunes con cadenas

- `occursin(a, c)`: Devuelve `true` si la cadena `a` es una subcadena de `c`, y `false` en caso contrario.
- `contains(c, a)`: Devuelve `true` si la cadena `a` es una subcadena de `c`, y `false` en caso contrario.
- `replace(c, a => b)`: Devuelve la cadena que resulta de sustituir la cadena `a` por la `b` en la cadena `c`.
- `lowercase(c)`: Devuelve la cadena `c` en min√∫sculas.
- `uppercase(c)`: Devuelve la cadena `c` en may√∫sculas.
- `prefix(c, a)`: Devuelve `true` si la cadena `a` es un prefijo de la cadena `c`.
- `suffix(c, a)`: Devuelve `true` si la cadena `a` es un sufijo de la cadena `c`.
- `split(c, a)`: Devuelve una lista con las cadenas que resulpan de partir la cadena `c` por el delimitador `a`.

---

### Ejemplo de otras operaciones con cadenas

```julia
julia> c = "Hola Julia"
"Hola Julia"

julia> length(c)
10

julia> findfirst("a", c) 
4:4

julia> findlast("Ju", c)
6:7

julia> findlast("x", c)

julia> occursin("Julia", c)
true

julia> occursin("julia", c)
false

julia> replace(c, "a" => "o")
"Holo Julio"

julia> uppercase(c)
"HOLA JULIA"

julia> split(c, " ")
2-element Vector{SubString{String}}:
 "Hola"
 "Julia"
```

# Estructuras de control

## Condicionales

> `if` _condici√≥n 1_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo 1_  
  `elseif` _condici√≥n 2_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo 2_  
  ...  
  `else`  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo n_  
  `end`

La indentaci√≥n de los bloques de c√≥digo no es necesaria, pero es una buena pr√°ctica.

---

### Ejemplo de condicional

```julia
julia> x = -1
-1

julia> if x > 0
         signo = "positivo"
       elseif x < 0
         signo = "negativo"
       else
         signo = "nulo"
       end
"negativo"
```
---

### Operador condicional

Una forma abreviada de la estructura condicional es el operador condicional. 

> _condici√≥n_ `?` _bloque true_ `:` _bloque false_

Este operador ejecuta el primer bloque de c√≥digo si la condici√≥n es `true` y el segundo en caso contrario.

```julia
julia> x > 0 ? signo = "positivo" : signo = "negativo"
"negativo"
```

## Bucles

## Bucles iterativos

> `for` _iterador_ `in` _secuencia_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo_  
  `end`

Ejecuta el bloque de c√≥digo tantas veces como elementos tenga la _secuencia_. En cada iteraci√≥n el _iterador_ toma como valor el siguiente elemento de la _secuencia_.  

```julia
julia> c = "Julia"
"Julia"

julia> for i in c
         println(i)
       end
J
u
l
i
a
```

---

### Bucles iterativos con rangos

En muchas ocasiones la secuencia que se recorre en un bucle iterativo se genera mediante un rango, que es una secuencia de n√∫meros igualmente espaciados. Existen distintas funciones para generar rangos:

- `i:j`: Genera la secuenciad de n√∫meros desde `i` hasta `j`.
- `i:j:k`: Genera la secuencia de n√∫meros desde `i` hasta `k` dando saltos de `j`.
- `StepRange(i, j, k)`: Genera la secuencia de n√∫meros desde `i` hasta `k` dando saltos de `j`.
- `range(i, j, n)`: Genera una secuencia de `n` n√∫meros desde `i` hasta `j`.

---

### Ejemplo de bucles iterativos con rangos

```julia
julia> for i in 1:2:10
         println(i)
       end
1
3
5
7
9

julia> for i = range(0, 10, 5)
         println(i)
       end
0.0
2.5
5.0
7.5
10.0
```

---

### Bucles iterativos anidados

En muchas ocasiones es habitual incluir un bucle iterativo en el bloque de c√≥digo de otro bucle iterativo, lo que se conoce como _bucles anidados_.

Julia permite simplicar estas estructuras indicando los iteradores en la cabecera de un √∫nico bucle.

```julia
julia> for i in "abc", j = 1:2
         println(i,j)
       end
a1
a2
b1
b2
c1
c2
```

## Bucles condicionales

> `while` _condici√≥n_  
  &nbsp;&nbsp;&nbsp;_bloque c√≥digo_  
  `end`

Repite la ejecuci√≥n del bloque de c√≥digo mientras que la _condici√≥n_ sea cierta.

```julia
julia> x = 3
3

julia> while x >= 0
          println(x)
          x -= 1
       end
3
2
1
0
```

---

### Interrupci√≥n de bucles

La instrucci√≥n `break` provoca inmediatamente la finalizaci√≥n de un bucle tanto iterativo como condicional.

```julia
julia> x=3
3

julia> while true
          if x < 0 
             break
          end
          println(x)
          x -= 1
       end
3
2
1
0
```

---

### Salto de bucles

La instrucci√≥n `continue` provoca la finalizaci√≥n del bloque de c√≥digo de un bucle y pasa inmediatamente a la siguiente iteraci√≥n.

```julia
julia> for i in 1:10
          if i % 2 == 0
             continue
          end
          println(i)
       end
1
3
5
7
9
```

# Tipos de datos compuestos

## Colecciones de datos

Colecciones de datos con distinta estructura y sem√°ntica.

- Arrays
  - Vectores
  - Matrices
- Tuplas
- Diccionarios
- Conjuntos

## Arrays 

Un **array** es una colecci√≥n ordenada de datos de un mismo tipo.

El tipo del array se infiere autom√°ticamente a partir de los tipos de sus elementos. Si los elementos son de distintos tipos se convierten al tipo m√°s espec√≠fico de la jerarqu√≠a de tipos del que los tipos de los elementos son subtipos.

Se construyen escribiendo sus elementos separados por comas, puntos y comas o espacios entre corchetes.

```julia
julia> [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> [1.0, "julia", true]
3-element Vector{Any}:
    1.0
     "julia"
 true
```

## Arrays multidimensionales

Los arrays pueden estructurar sus elementos en m√∫ltiples dimensiones. Dependiendo el n√∫mero de dimesiones tenemos distintos tipos de arrays:

![](img/arrays.png){}

---

### Funciones de arrays

- `length(A)`: Devuelve el n√∫mero de elementos del array `A`.
- `eltype(A)`: Deuvelve el tipo de los elementos del array `A`.
- `ndims(A)`: Devuelve el n√∫mero de dimensiones del array `A`.
- `size(A)`: Devuelve una tupla con los tama√±os de las dimensiones del array `A`.
- `size(A, n)`: Devuelve el tama√±o de la dimensi√≥n `n` del array `A`.
- `axes(A)`: Devuelve una tupla con los √≠ndices v√°lidos de cada dimensi√≥n del array `A`. 
- `axes(A, n)`: Devuelve un rango con los √≠ndices v√°lidos de la dimensi√≥n `n` del array `A`.
- `eachindex(A)`: Devuelve un iterador sobre los √≠ndices de los elementos del array `A`.

---

### Constructores de arrays

- `zeros(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos ceros.
- `ones(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos unos.
- `fill(a, dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos iguales `a`.
- `rand(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos n√∫meros aleatorios entre 0 y 1.
- `trues(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos `true`.
- `falses(dim)`: Devuelve un array de la dimensiones indicadas por la tupla `dim` con todos sus elementos `false`.

---

### Ejemplos de constructores de arrays

```julia
julia> zeros(3)  # Vector de tama√±o 3
3-element Vector{Float64}:
 0.0
 0.0
 0.0

julia> rand(3,2)  # Matriz de tama√±o 3 x 2
3√ó2 Matrix{Float64}:
 0.1469    0.891839
 0.953462  0.395681
 0.819468  0.720606

julia> fill(œÄ, 2, 2)
2√ó2 Matrix{Irrational{:œÄ}}:
 œÄ  œÄ
 œÄ  œÄ
```

---

### Redimiensionado de arrays

La siguientes funciones permiten cambiar las dimensiones de un array, reestructurando sus elementos:

- `rehape(A, dim)`: Devuelve el array que resulta de redimiensionar el array `A` con las dimensiones indicadas por la tupla `dim`.
- `permutedims(A)`: Devuelve el array de resulta de trasponer el array `A`.

:::{.callout-warning}
El array resultante debe tener los mismos elementos que el array original, por lo que si las dimensiones no son compatibles se produce un error.
:::

---

### Ejemplo de redimensionado de arrays

```julia
julia> v = [1, 2, 3, 4, 5, 6]
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6

julia> reshape(v, 2, 3)
2√ó3 Matrix{Int64}:
 1  3  5
 2  4  6

julia> reshape(v, 3, 2)
3√ó2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia> permutedims(reshape(v, 3, 2))
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6
```

---

### Comprensi√≥n de arrays

Una potente t√©cnica de creaci√≥n de arrays es la comprensi√≥n de arrays, que consiste en generar los elementos del array a partir de uno o varios iteradores.

- `[exp for i = ite]`: Devuelve el vector cuyos elementos resultan de evaluar a expresi√≥n `exp` para cada valor `i` del iterador `ite`.

- `[exp for i = ite if cond]`: Devuelve el vector cuyos elementos resultan de evaluar a expresi√≥n `exp` para cada valor `i` del iterador `ite` que cumpla la condici√≥n `cond`.

Se pueden utilizar varios iteradores para crear arrays de varias dimensiones. 

---

```julia
julia> [i^2 for i = 1:4]
4-element Vector{Int64}:
  1
  4
  9
 16

julia> [i^2 for i = 1:4 if i % 2 == 0]
2-element Vector{Int64}:
  4
 16

julia> [i+j for i = 1:2, j = 3:4]
2√ó2 Matrix{Int64}:
 4  5
 5  6
```


## Vectores

Los vectores son arrays de una dimensi√≥n.

Se construyen escribiendo sus elementos separados por comas o puntos y comas entre corchetes.

```julia
julia> v = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia> length(v)
3

julia> eltype(v)
Int64

julia> ndims(v)
1

julia> size(v)
(3,)

julia> eachindex(v)
Base.OneTo(3)
```
---

### Acceso a los elementos de un vector

El acceso a los elementos de un vector es mediante _√≠ndices_. Cada elemento del vector tiene asociado un √≠ndice entero que se corresponde con su posici√≥n desde 1 hasta el n√∫mero de elementos. 

- `v[i]`: Devuelve el elemento del vector `v` con √≠ndice `i`.

:::{.callout-warning}
Si se proporciona un √≠ndice no v√°lido se produce un error.
:::

Las palabras reservadas `begin` y `end` se utilizan para referirse al primer y √∫ltimo √≠ndice de un vector.

---

### Ejemplo de acceso a los elementos de un vector

```julia
julia> v = [2, 4, 6]
3-element Vector{Int64}:
 2
 4
 6

julia> v[2]
4

julia> v[end]
6

julia> v[4]
ERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]
Stacktrace:
 [1] getindex(A::Vector{Int64}, i1::Int64)
   @ Base ./array.jl:861
 [2] top-level scope
   @ REPL[4]:1
```

---

### Acceso a m√∫ltiples elementos de un vector

Es posible extraer varios elementos de un vector a la vez indicando los √≠ndices mediante un rango o un vector de enteros.

- `v[i:j]`: Devuelve un vector con los elementos del vector `v` desde el √≠ndice `i` al `j`.
- `v[u]`: Devuelve un vector con los elementos del vector `v` correspondientes a los √≠ndices del vector `u`.

```julia
julia> v = [2, 4, 6, 8];

julia> v[2:3]
2-element Vector{Int64}:
 4
 6

julia> v[[2,4,3]]
3-element Vector{Int64}:
 4
 8
 6
```

---

### Modificaci√≥n de los elementos de un vector

Tambi√©n es posible modificar un vector asignando nuevos elementos mediante los √≠ndices.

- `v[i] = a`: A√±ade el elemento `a` al vector `v` en el √≠ndice `i`.

```julia
julia> v = [2, 4, 6]
3-element Vector{Int64}:
 2
 4
 6

julia> v[2] = 0
0

julia> v
3-element Vector{Int64}:
 2
 0
 6
```

---

### A√±adir elementos a un vector

Las siguientes funciones permiten a√±adir elementos al final de un vector:

- `push!(v, a)`: A√±ade el elemento `a` al final del vector `v`.
- `append!(v, u)`: A√±ade los elementos del vector `u` al final del vector `v`.

```julia
julia> v = [];

julia> push!(v, 1)
1-element Vector{Any}:
 1

julia> append!(v, [2, 3])
3-element Vector{Any}:
 1
 2
 3

julia> v
3-element Vector{Any}:
 1
 2
 3
```

---

### Recorrer un vector

Una operaci√≥n habitual es recorrer los elementos de un vector para hacer cualquier operaci√≥n con ellos. Existen dos posibilidades: recorrer el vector por √≠ndice o por valor.

```julia
julia> v = [2, 4, 6];

julia> for i in v  # Recorrido por valor
         println(i)
       end
2
4
6

julia> for i in eachindex(v)  # Recorrido por √≠ndice
         println(v[i])
       end
2
4
6
```

---


### Operaciones con vectores num√©ricos

- `minimum(v)`: Devuelve el menor elemento del vector `v`.
- `maximum(v)`: Devuelve el mayor elemento del vector `v`.
- `argmin(v)`: Devuelve el √≠ndice del menor elemento del vector `v`.
- `argmax(v)`: Devuelve el √≠ndice del mayor elemento del vector `v`.
- `sum(v)`: Devuelve la suma de los elementos del vector `v`.
- `prod(v)`: Devuelve el producto de los elementos del vector `v`.
- `unique(v)`: Devuelve un vector con los elementos de `v` sin repetir.

```julia
julia> v = [4, 2, 3];

julia> maximum(v)
4

julia> argmax(v)
1

julia> sum(v)
9

julia> prod(v)
24
```

---

### Ordenaci√≥n de vectores

- `sort(v, rev=true)`: Devuelve el vector que resulta de ordenar en orden ascendente los elementos del vector `v`. Si se pasa `true` al par√°metro `rev` el orden es descendente.
- `sort!(v, rev=true)`: Ordena el vector `v` en orden ascendente. Si se pasa `true` al par√°metro `rev` el orden es descendente. 
- `reverse(v)`: Devuelve el vector con los elementos del vector `v` en orden inverso.
- `reverse!(v)`: Modifica el vector `v` poniendo sus elementos en orden inverso.

---

### Ejemplo de ordenaci√≥n de vectores

```julia
julia> v = [4, 2, 3];

julia> sort(v)
3-element Vector{Int64}:
 2
 3
 4

julia> reverse(v)
3-element Vector{Int64}:
 3
 2
 4

julia> v
3-element Vector{Int64}:
 4
 2
 3

julia> reverse!(v)
3-element Vector{Int64}:
 3
 2
 4

julia> v
3-element Vector{Int64}:
 3
 2
 4
```

---

### Extensi√≥n de funciones a vectores

Si una funci√≥n recibe un par√°metro del tipo de los elementos de un vector, se puede aplicar la funci√≥n a cada uno de los elementos del vector, extendiendo la llamada de la funci√≥n sobre los elementos del vector. Para ello basta con a√±adir un punto entre el nombre de la funci√≥n y el par√©ntesis de los argumentos.

- `f.(v)`: Devuelve el vector que resulta de aplicar la funci√≥n `f` a cada uno de los elementos del vector `v`. 

:::{.callout-warning}
En la llamada a la funci√≥n hay que pasarle com argumentos tantos vectores como par√°metros tenga la funci√≥n. Si los vectores son de distinto tama√±o, se reciclan los de menor tama√±o.
:::

:::{.callout-warning}
Si la funci√≥n no devuelve ning√∫n valor el resultado es un vector de valores `nothing`.
:::

La extensi√≥n de funciones tambi√©n funciona con operadores, poniendo el punto delante del operador.

---

### Ejemplo de extensi√≥n de funciones a vectores

```julia
julia> v = [1, 4, 9];

julia> sqrt.(v)
3-element Vector{Float64}:
 1.0
 2.0
 3.0

julia> v .^ 2
3-element Vector{Int64}:
  1
 16
 81

julia> base = [2, ‚ÑØ, 10];

julia> log.(base, v)
3-element Vector{Float64}:
 0.0
 1.3862943611198906
 0.9542425094393249
```

---

### Filtrado de vectores

Otra operaci√≥n bastante com√∫n son los filtros de vectores. Se puede filtrar un vector a partir de un vector de booleanos del mismo tama√±o. 

- `v[u]`: Devuelve el vector con los elementos que tienen el mismo √≠ndice que los valores `true` del vector booleano `u`.

Esto permite aplicar filtros a partir de condiciones que devuelvan un vector de booleanos.

---

### Ejemplo de filtrado de vectores

```julia
julia> v = [1, 2, 3, 4];

julia> v[[true, false, true, false]]
2-element Vector{Int64}:
 1
 3

julia> v .% 2 .== 0  # Condici√≥n
4-element BitVector:
 0
 1
 0
 1

julia> v[v .% 2 .== 0]  # Filtro de n√∫meros pares
2-element Vector{Int64}:
 2
 4
```

---

### √Ålgebra lineal con vectores

- `u` + `v`: Devuelve el vector que resulta de la suma de los vetores `u` y `v`.
- `u` - `v`: Devuelve el vector que resulta de la resta de los vetores `u` y `v`.
- `a * v`: De vuelve el vector que resulta de multiplicar el vector `v` por el escalar `a`.
- `v'`: Devuelve el vector que resulta de trasponer el vector `v`. Si `v` es un vector fila, `v'` es un vector columna y viceversa.

Con el paquete [`LinearAlgebra`](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/) tambi√©n est√°n disponibles las siguientes funciones:

- `dot(u, v)`: Devuelve el producto escalar de los vectores `u` y `v`.
- `norm(v)`: Devuelve la norma (m√≥dulo) del vector `v`.

---

### Ejemplo de √°lgebra lineal con vectores

```julia
julia> u = [1, 2, 3]; v = [1, 0, 2];

julia> u + v
3-element Vector{Int64}:
 2
 2
 5

julia> 2u
3-element Vector{Int64}:
 2
 4
 6

julia> dot(u, v)  # Producto escalar
7

julia> u'v  # Producto escalar
7

julia> norm(v)  # Norma o m√≥dulo
2.23606797749979

julia> u / norm(u)  # Vector unitario
3-element Vector{Float64}:
 0.2672612419124244
 0.5345224838248488
 0.8017837257372732
```

## Matrices

Las matrices son arrays de dos dimensiones (filas x columnas).

Se construyen escribiendo sus elementos entre corchetes, separando los elementos por espacio y las filas por punto y coma `;`.

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> length(A)
6

julia> eltype(A)
Int64

julia> ndims(A)
2

julia> size(A)
(2, 3)
```

---

### Acceso a los elementos de una matriz

El acceso a los elementos de una matriz es mediante _√≠ndices_. Cada elemento de la matriz tiene asociado un par de √≠ndices enteros que se corresponde la fila y la columna que ocupa. 

- `A[i, j]`: Devuelve el elemento de la matriz `A` con √≠ndice de fila `i` e √≠ndice de columna `j`.

:::{.callout-warning}
Si se proporciona alg√∫n √≠ndice no v√°lido se produce un error.
:::

Tambi√©n se puede acceder a los elementos de una matriz mediante un √∫nico √≠ndice. En ese caso se obtiene el elemento con ese √≠ndice en el vector que resulta de concatenar los elementos de la matriz por columnas. 

---

### Ejemplo de acceso a los elementos de una matriz

```julia
julia> A = reshape(1:6, 2, 3)
2√ó3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6

julia> A[2, 1]
2

julia> A[4]
4
```
---

### Acceso a m√∫ltiples elementos de una matriz

Es posible extraer varios elementos de una matriz a la vez indicando los √≠ndices de las filas y las columnas mediante un rango o un vector de enteros.

- `A[i:j, k:l]`: Devuelve una matriz con los elementos desde el √≠ndice de fila `i` al `j` y el √≠ndice de columna `k` al `l` de la matriz `A`.
- `A[u, w]`: Devuelve una matriz con los elementos correspondientes a los √≠ndices de fila del vector `u` y los √≠ndices de columna del vector `w` de la matriz `A`.

---

## Ejemplo de acceso a m√∫ltiples elementos de una matriz

```julia
julia> A = reshape(1:9, 3, :)
3√ó3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:
 1  4  7
 2  5  8
 3  6  9

julia> A[1:2, 2:3]
2√ó2 Matrix{Int64}:
 4  7
 5  8

julia> A[[1, 3], [3, 1]]
2√ó2 Matrix{Int64}:
 7  1
 9  3

julia> A[2, :]  # Segundo vector fila
3-element Vector{Int64}:
 2
 5
 8
```

---

### Modificaci√≥n de los elementos de una matriz

Tambi√©n es posible modificar una matriz asignando nuevos elementos mediante los √≠ndices de fila y columna.

- `A[i, j] = a`: A√±ade el elemento `a` a la matriz `A` con el √≠ndice de fila `i` y el √≠ndice de columna `j`.

```julia
julia> A = zeros(2, 3)
2√ó3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> A[2,3] = 1
1

julia> A
2√ó3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  1.0
```

---

### Concatenaci√≥n de matrices

Dos o m√°s matrices pueden concatenarse horizontal o verticalmente siempre que sus dimensiones sean compatibles.

- `[A B]`: Devuelve la matriz que resulta de concatenar horizontalmente las matrices `A` y `B`. Ambas matrices deben tener el mismo n√∫mero de filas.
- `[A; B]`: Devuelve la matriz que resulta de concatenar verticalmente las matrices `A` y `B`. Ambas matrices deben tener el mismo n√∫mero de columnas.

---

### Ejemplo de concatenaci√≥n de matrices

```julia
julia> A = zeros(2, 2)
2√ó2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0

julia> B = ones(2, 1)
2√ó1 Matrix{Float64}:
 1.0
 1.0

julia> C = ones(1, 3)
1√ó3 Matrix{Float64}:
 1.0  1.0  1.0

julia> D = [A B]
2√ó3 Matrix{Float64}:
 0.0  0.0  1.0
 0.0  0.0  1.0

julia> [D ; C]
3√ó3 Matrix{Float64}:
 0.0  0.0  1.0
 0.0  0.0  1.0
 1.0  1.0  1.0
```

---

### Concatenaci√≥n de vectores

Tambi√©n es posible concatenar varios vectores horizontalmente o verticalmente para formar una matriz. 

- `hcat(v...)`: Devuelve la matriz que resulta de concatenar horizontalmente los vectores del vector `v`.
- `vcat(v...)`: Devuelve la matriz que resulta de concatenar verticalmente los vectores del vector `v`.

---

### Ejemplo de concatenaci√≥n de vectores

```julia
julia> v = [[1, 2, 3], [4, 5, 6]]
2-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [4, 5, 6]

julia> hcat(v...)
3√ó2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia> v = [[1 2 3], [4 5 6]]
2-element Vector{Matrix{Int64}}:
 [1 2 3]
 [4 5 6]

julia> vcat(v...)
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6
```

### Recorrido de matrices

Una operaci√≥n habitual es recorrer los elementos de una matriz para hacer una operaci√≥n con ellos. El recorrido se suele hacer con dos bucles iterativos anidados.

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> for i = 1:size(A, 1), j = 1:size(A, 2)  # Recorrido por filas
         println(A[i, j])
       end
1
2
3
4
5
6

julia> for j = 1:size(A, 2), i = 1:size(A, 1)  # Recorrido por columnas
         println(A[i, j])
       end
1
4
2
5
3
6
```

---

### Operaciones con matrices num√©ricas

- `minimum(A)`: Devuelve el menor elemento de la matriz `A`.
- `maximum(A)`: Devuelve el mayor elemento de la matriz `A`.
- `argmin(A)`: Devuelve los √≠ndices de fila y columna del menor elemento de la matriz `A`.
- `argmax(A)`: Devuelve los √≠ndices de fila y columna del mayor elemento de la matriz `A`.
- `sum(A)`: Devuelve la suma de los elementos de la matriz `A`.
- `prod(A)`: Devuelve el producto de los elementos de la matriz `A`.

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> minimum(A)
1

julia> argmax(A)
CartesianIndex(2, 3)

julia> sum(A)
21

julia> prod(A)
720
```

---

### Extensi√≥n de funciones a matrices

Al igual que para vectores, se puede aplicar una una funci√≥n a todos los elementos de una matriz. Para ello basta con a√±adir un punto entre el nombre de la funci√≥n y el par√©ntesis de los argumentos.

- `f.(A)`: Devuelve la matriz que resulta de aplicar la funci√≥n `f` a cada uno de los elementos de la matriz `A`. 

:::{.callout-warning}
En la llamada a la funci√≥n hay que pasarle com argumentos tantos vectores como par√°metros tenga la funci√≥n. Si las matrices son de distinto tama√±o, se reciclan las de menor tama√±o.
:::

La extensi√≥n de funciones tambi√©n funciona con operadores, poniendo el punto delante del operador.

---

### Ejemplo de extensi√≥n de funciones a matrices

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> sqrt.(A)
2√ó3 Matrix{Float64}:
 1.0  1.41421  1.73205
 2.0  2.23607  2.44949

julia> A .+ 1
2√ó3 Matrix{Int64}:
 2  3  4
 5  6  7
```

---

### √Ålgebra lineal con matrices

- `A` + `B`: Devuelve la matriz que resulta de la suma de las matrices `A` y `B`. Ambas matrices deben tener las mismas dimensiones.
- `A` - `B`: Devuelve la matriz que resulta de la resta de las matrices `A` y `B`. Ambas matrices deben tener las mismas dimensiones.
- `a * A`: Devuelve la matriz que resulta de multiplicar la matriz `A` por el escalar `a`.
- `A * B`: Devuelve la matriz producto de las matrices `A` y `B`. El n√∫mero de columnas de `A` debe coincidir con el n√∫mero de filas de `B`.
- `A'`: Devuelve la matriz traspuesta de la matriz `A`.
- `transpose(A)`: Devuelve la matriz traspuesta de la matriz `A`.

---

### Ejemplo de √°lgebra lineal con matrices

```julia
julia> A = [1 2 3; 4 5 6]
2√ó3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> B = [1 1 1; 2 2 2]
2√ó3 Matrix{Int64}:
 1  1  1
 2  2  2

julia> A + B
2√ó3 Matrix{Int64}:
 2  3  4
 6  7  8

julia> C = A'
3√ó2 adjoint(::Matrix{Int64}) with eltype Int64:
 1  4
 2  5
 3  6

julia> A * C
2√ó2 Matrix{Int64}:
 14  32
 32  77

julia> C * A
3√ó3 Matrix{Int64}:
 17  22  27
 22  29  36
 27  36  45

```

### √Ålgebra lineal con matrices

El paquete [`LinearAlgebra`](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/) define las siguientes funciones:

- `Matrix(I, n, n)`. Devuelve la matriz identidad de dimensi√≥n `n`.
- `diag(A)`: Devuelve un vector con los elementos de la diagonal principal de la matriz `A`.
- `norm(A)`: Devuelve la norma de Frobenius de la matriz `A`.
- `tr(A)`: Devuelve la traza de la matriz cuadrada `A`.
- `det(A)`: Devuelve el determinante de la matriz cuadrada `A`.
- `inv(A)`: Devuelve la matriz inversa de la matriz cuadrada `A`.
- `A \ B`: Devuelve el vector `x` soluci√≥n del sistema de ecuaciones $Ax = B$, donde `A` es una matriz cuadrada y `B` es un vector del mismo tama√±o que el n√∫mero de filas o columnas de `A`.

---

### Ejemplo de √°lgebra lineal con matrices

```julia
julia> Matrix(I, 3, 3)
3√ó3 Matrix{Bool}:
 1  0  0
 0  1  0
 0  0  1

julia> A = [1 2 3; 0 1 0; 1 0 1]
3√ó3 Matrix{Int64}:
 1  2  3
 0  1  0
 1  0  1

julia> diag(A)
3-element Vector{Int64}:
 1
 1
 1

julia> norm(A)
4.123105625617661

julia> tr(A)
3

julia> det(A)
-2.0

julia> inv(A)
3√ó3 Matrix{Float64}:
 -0.5   1.0   1.5
  0.0   1.0   0.0
  0.5  -1.0  -0.5

julia> B = [10, 2, 4]
3-element Vector{Int64}:
 10
  2
  4

julia> A \ B  # Soluci√≥n del sistema Ax = B
3-element Vector{Float64}:
 3.0
 2.0
 1.0
```

---

### √Ålgebra lineal con matrices

Otras funciones m√°s avanzadas del paque `LinearAlgebra` son:

- `eigvals(A)`: Devuelve un vector con los autovalores de la matriz `A`. 
- `eigvecs(A)`: Devuelve la matriz con los autovectore de la matriz `A`.
- `factorize(A)`: Devuelve las matrices resultantes de la factorizaci√≥n de la matriz `A`. La factorizaci√≥n depender√° de las propiedades de `A` (ver [tipos de factorizaci√≥n](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#man-linalg-factorizations))

---

### Ejemplos de √Ålgebra lineal con matrices

```julia
julia> A = [1 2; 3 1]
2√ó2 Matrix{Int64}:
 1  2
 3  1

julia> eigvals(A)
2-element Vector{Float64}:
 -1.4494897427831779
  3.4494897427831783

julia> eigvecs(A)
2√ó2 Matrix{Float64}:
 -0.632456  0.632456
  0.774597  0.774597

julia> B = [1 2; 2 1]
2√ó2 Matrix{Int64}:
 1  2
 2  1

julia> factorize(B)
LU{Float64, Tridiagonal{Float64, Vector{Float64}}}
L factor:
2√ó2 Matrix{Float64}:
 1.0  0.0
 0.5  1.0
U factor:
2√ó2 Matrix{Float64}:
 2.0  1.0
 0.0  1.5
```

---

### Copia de tipos de datos compuestas

En Julia cuando se asigna una variable de un tipo de datos compuesto a otra variable, no se hace una copia de la estructura de datos referenciada por la primera variable, sino que se la nueva variable apunta a la misma direcci√≥n de memoria de la estructura de datos (copia por referencia). El resultado son dos variables que apuntan a la misma estructura de datos y cualquier cambio en una de ellas se ver√° reflejado en la otra. 

Para hacer copias por valor de un tipo de datos compuesto debe usarse expl√≠citamente la siguiente funci√≥n:

- `b = copy(a)`: Crea una copia de la estructura de datos referencia por `a` y asigna su referencia a `b`.

---

### Ejemplo de copia de tipos de datos compuestos

```julia
julia> v = [1, 2, 3];

julia> u = copy(v);  # Copia por valor

julia> u[2] = 0;

julia> u
3-element Vector{Int64}:
 1
 0
 3

julia> v
3-element Vector{Int64}:
 1
 2
 3

julia> u = v;  # Copia por referencia

julia> u[2]=0;

julia> v
3-element Vector{Int64}:
 1
 0
 3
```

## Tuplas

Una tupla es una colecci√≥n ordenada de tama√±o fijo que puede contenere elementos de distintos tipos. 

Generalmente se usan para pasar par√°metros o devolver valores de funciones.

Se crean escribiendo sus elementos separados por comas entre par√©ntesis.

:::{.callout-warning}
Las tuplas son inmutables, es decir, una vez creadas no pueden cambiarse sus elementos.
:::

```julia
julia> ()  # Tupla vac√≠a
()

julia> (1, "enero", 2020) 
(1, "enero", 2020)

julia> t = (1, "enero", 2020)
(1, "enero", 2020)

julia> typeof(t)
Tuple{Int64, String, Int64}
```

---

### Tuplas con nombres

Es posible asignar un nombre a cada uno de los elementos de la tupla. Para ello cada elemento de la tupla con nombre debe escribirse con la sintaxis `nombre = valor`.

```julia
ulia> t = (d√≠a = 1, mes = "enero", a√±o =  2020)
(d√≠a = 1, mes = "enero", a√±o = 2020)

julia> typeof(t)
NamedTuple{(:d√≠a, :mes, :a√±o), Tuple{Int64, String, Int64}}
```

:::{.callout-warning}
No puede haber dos elementos con el mismo nombre en una tupla.
:::

La ventaja de usar tuplas con nombres es que podemos acceder a sus elementos por nombre, adem√°s de por √≠ndice.

---

### Acceso a los elementos de una tupla

Como las tuplas tienen orden, podemos acceder a sus elementos mediante √≠ndices, al igual que con los arrays de una dimensi√≥n. 

- `t[i]`: Devuelve el elemento con √≠ncide `i` de la tupla `t`.

Si la tupla tiene nombres tambi√©n es posible acceder a sus elementos mediante los nombres.

- `t.x`: Devuelve el elemento con nombre `x` de la tupla `t`.

```julia
julia> t = (d√≠a = 1, mes = "enero", a√±o =  2020)
(d√≠a = 1, mes = "enero", a√±o = 2020)

julia> t[2]
"enero"

julia> t.a√±o
2020

julia> 
```

---

### Asignaci√≥n m√∫ltiple de tuplas

Es posible asignar los elementos de una tupla a distintas variables en una sola asignaci√≥n.

`x, y, ... = t`: Asigna a las variables `x`, `y`, etc los elementos de la tupla `t` en orden. Si el n√∫mero de variables es menor que el tama√±o de la tupla, los √∫ltimos elementos quedan sin asignar.

`x, y... = t`: Asigna el primer elemento de la tupla `t` a la variable `x` y la tupla con los elementos restantes a la variable `y`.

---

### Ejemplo de asignaci√≥n m√∫ltipe de tuplas

```julia
julia> t = (1, "enero", 2020)
(1, "enero", 2020)

julia> d, m, a = t
(1, "enero", 2020)

julia> d
1

julia> m
"enero"

julia> a
2020

julia> d, ma... = t 
(1, "enero", 2020)

julia> d
1

julia> ma
("enero", 2020)
```

## Diccionarios

Un diccionario es una colecci√≥n asociativa sin orden cuyos elementos son pares formados por una _clave_ y un _valor_ asociado a la clave. 

Se parecen a las tuplas con nombre, pero, a diferencia de estas, son mutables, es decir, su contenido se puede alterar.

Se construyen con la siguiente constructor:

- `Dic(k1 = v1, ...)`: Crea un diccionario con los pares indicados en formato `clave = valor`.

:::{.callout-warning}
En un diccionario no pueden existir dos pares con la misma clave, de modo que si se repite una clave se sobreescribe el par anterior.
:::

---

### Ejemplo de diccionarios

```julia
julia> Dict()  # Diccionario vac√≠o
Dict{Any, Any}()

julia> d = Dict("ES" => "Euro", "US" => "Dollar", "CN" => "Yuan")
Dict{String, String} with 3 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "US" => "Dollar"

julia> typeof(d)
Dict{String, String}
```

### Comprensi√≥n de diccionarios

Al igual que para arrays se puede usar la t√©cnica de compresi√≥n para generar diccionarios a partir de uno o varios iteradores.

- `Dict(kexp => vexp for i = ite)`: Devuelve el diccionario cuyos pares est√°n formados por la claves y valores resultan de evaluar las expresiones `kexp` y `vexp` respectivamente, para cada valor `i` del iterador `ite`.

- `Dict(kexp => vexp for i = ite if cond)`: Devuelve el diccionario cuyos pares est√°n formados por la claves y valores resultan de evaluar las expresiones `kexp` y `vexp` respectivamente, para cada valor `i` del iterador `ite` que cumpla condici√≥n `cond`.

Se pueden utilizar m√°s de un iterador despu√©s de la palabra reservada `for`.

---

### Ejemplo de comprensi√≥n de diccionarios

```julia
julia> Dict(i => i^2 for i = 1:4)
Dict{Int64, Int64} with 4 entries:
  4 => 16
  2 => 4
  3 => 9
  1 => 1

julia> Dict(i => i^2 for i = 1:4 if i % 2 == 0)
Dict{Int64, Int64} with 2 entries:
  4 => 16
  2 => 4

julia> Dict((i, j) => i + j for i = 1:2, j = 3:4)
Dict{Tuple{Int64, Int64}, Int64} with 4 entries:
  (2, 4) => 6
  (1, 3) => 4
  (1, 4) => 5
  (2, 3) => 5
```

---

### Acceso a los elementos de un diccionario

Para acceder a los valores de un diccionario se utilizan sus claves asociadas entre corchetes.

- `d[k]`: Devuelve el valor asociado a la clave `k` en el diccionario `d`.

:::{.callout-warning}
Si la clave no existe en el diccionario se produce un error.
:::

Para evitar errores es conveniente usar alguna de las siguientes funciones:

- `haskey(d, k)`: Devuelve `true` la clave `k` est√° en diccionario `d` y `false` en caso contrario.
- `get(d, k, v)`: Devuelve el valor asociado a la clave `k` en el diccionario `d` o el valor `v` si la clave `k` no existe.
- `get!(d, k, v)`: Devuelve el valor asociado a la clave `k` en el diccionario `d`. Si la clave `k` no existe en el diccionario `d` a√±ade el par con la clave `k` y el valor `v` y devuelve el valor `v`.

---

### Ejemplo de acceso a los elementos de un diccionario

```julia
julia> d = Dict("ES" => "Euro", "US" => "Dollar", "CN" => "Yuan")
Dict{String, String} with 3 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "US" => "Dollar"

julia> d["ES"]
"Euro"

julia> d["JP"]
ERROR: KeyError: key "JP" not found
Stacktrace:
 [1] getindex(h::Dict{String, String}, key::String)
   @ Base ./dict.jl:481
 [2] top-level scope
   @ REPL[22]:1

julia> get(d, "JP", "Dollar")
"Dollar"

julia> get!(d, "JP", "Yen")
"Yen"

julia> d
Dict{String, String} with 4 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "JP" => "Yen"
  "US" => "Dollar"
```

---

### Recorrido de las claves y valores de un diccionario

Las siguientes funciones permiten obtener todas las claves, valores y pares de un diccionario.

- `keys(d)`: Devuelve un iterador con las claves del diccionario `d`.
- `values(d)`: Devuelve un iterador con las claves del diccionario `d`.

Estos iteradores permiten recorrer facilmente los pares de un diccionario.

---

### Ejemplo de recorrido de las claves y valores de un diccionario

```julia
julia> d = Dict("ES" => "Euro", "US" => "Dollar", "CN" => "Yuan")
Dict{String, String} with 3 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "US" => "Dollar"

julia> keys(d)
KeySet for a Dict{String, String} with 3 entries. Keys:
  "CN"
  "ES"
  "US"

julia> values(d)
ValueIterator for a Dict{String, String} with 3 entries. Values:
  "Yuan"
  "Euro"
  "Dollar"

julia> for k = keys(d)
         println("$k = $(d[k])")
       end
CN = Yuan
ES = Euro
US = Dollar

julia> for (k, v) = d
       println("$k = $v")
       end
CN = Yuan
ES = Euro
US = Dollar
```

---

### A√±adir elementos a un diccionario

Se pueden a√±adir pares nuevos a un diccionario de la siguiente manera:

- `d[k] = v`: A√±ade el par con clave `k` y valor `v` al diccionario `d`. Si la clave `k` ya exist√≠a en el diccionario `d`, cambia su valor asociaco por `v`.

- `push!(d, k => v)`: A√±ade el par con clave `k` y valor asociado `v` al diccionario `d`.

```julia
julia> d = Dict("ES" => "Euro", "US" => "Dollar")
Dict{String, String} with 2 entries:
  "ES" => "Euro"
  "US" => "Dollar"

julia> d["CN"] = "Yuan"
"Yuan"

julia> push!(d, "JP" => "Yen")
Dict{String, String} with 4 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "JP" => "Yen"
  "US" => "Dollar"
```

---

### Eliminar elementos de un diccionario

Para eliminar un par de un diccionario se utiliza la siguiente funci√≥n:

- `delete!(d, k)`: Elimina el par cuya clave es `k` del diccionario `d`.

```julia
julia> d = Dict("ES" => "Euro", "US" => "Dollar", "CN" => "Yuan")
Dict{String, String} with 3 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
  "US" => "Dollar"

julia> delete!(d, "US")
Dict{String, String} with 2 entries:
  "CN" => "Yuan"
  "ES" => "Euro"
```

--- 

## Conjuntos

Un conjunto es una colecci√≥n de elementos del mismo tipo sin orden y sin repeticiones.

Se construyen con la siguiente constructor:

- `Set(a)`: Crea un conjunto con los elementos del array `a`.

Al igual que para arrays el tipo se infiere autom√°ticamente a partir de los tipos de sus elementos. Si los elementos son de distintos tipos se convierten al tipo m√°s espec√≠fico de la jerarqu√≠a de tipos del que los tipos de los elementos son subtipos.

:::{.callout-warning}
Un conjunto no puede tener elementos repetidos, por lo que si el array contiene elementos repetidos solo se incluyen una vez.
:::

---

### Ejemplo de construcci√≥n de conjuntos

```julia
julia> Set()
Set{Any}()

julia> c = Set([1, "2", 3])
Set{Any} with 3 elements:
  "2"
  3
  1

julia> typeof(c)
Set{Any}
```

---

### A√±adir elementos a un conjunto

Para a√±adir elementos a un conjunto se utiliza la siguiente funci√≥n:

- `push!(c, e)`: A√±ade el elemento `e` al conjunto `c`.

:::{.callout-warning}
Si el elemento que se quiere a√±adir es de distinto tipo que los elemento del conjunto y no puede convertirse a este tipo, se produce un error.
:::

---

### Ejemplo de a√±adir elementos a un conjunto

```julia
ulia> c = Set(1:3)
Set{Int64} with 3 elements:
  2
  3
  1

julia> push!(c, 4)
Set{Int64} with 4 elements:
  4
  2
  3
  1

julia> push!(c, "cinco")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type Int64
Closest candidates are:
  convert(::Type{T}, ::T) where T<:Number at /usr/share/julia/base/number.jl:6
  convert(::Type{T}, ::Number) where T<:Number at /usr/share/julia/base/number.jl:7
  convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at /usr/share/julia/base/twiceprecision.jl:262
  ...
```

---

### Eliminar elementos de un conjunto

Para eleminiar elementos de un conjunto se utiliza la siguiente funci√≥n: 

- `delete!(c, e)`: Elimina el elemento `e` del conjunto `c`.

```julia
julia> c = Set(1:3)
Set{Int64} with 3 elements:
  2
  3
  1

julia> delete!(c, 2)
Set{Int64} with 2 elements:
  3
  1
```

---

### Recorrido de los elementos de un conjunto

Un conjunto puede utilizarse tambi√©n como un iterador para recorrer sus elementos.

```julia
julia> c = Set(1:3)
Set{Int64} with 3 elements:
  2
  3
  1

julia> for i = c
         println(i)
       end
2
3
1
```

---

### Pertenencia e inclusi√≥n de conjuntos

- `in(e, c)`, `e ‚àà c` : Devuelve `true` si el elemento `e` pertenece al conjunto `c` y `false` en caso contrario.
- `e ‚àâ c`: Devuelve `true` si el elemento `e` no  pertenece al conjunto `c` y `false` en caso contrario.
- `issubset(a, b)`, `a ‚äÜ b`: Devuelve `true` si todos los elementos de `a` pertenecen a `b` y `false` en caso contrario.
- `a ‚äà b`: Deuvelve `true` si hay alg√∫n elemento de `a` que no pertenece a `b`.
- `a ‚ää b`: Devuelve `true` si el conjunto `a` est√° contenido estrictamente en el conjunto `b`, es decir, todos los elementos de `a` pertenecen a `b` pero `a` y `b` son distintos.
- `isdisjoint(a, b)`: Devuelve `true` si los conjuntos `a` y `b` no tienen elementos en com√∫n y `false` en caso contrario.

---

### Ejemplos de pertenencia e inclusi√≥n de conjuntos

```julia
julia> a = Set(1:3);

julia> in(2, a)
true

julia> 3 ‚àâ a
false

julia> b = Set([3, 2, 1]);

julia> a ‚ää b
false

julia> a ‚äÜ b
true

julia> isdisjoint(a, b)
false
```

---

### √Ålgebra de conjuntos

- `union(a, b)`, `a ‚à™ b`: Devuelve el conjunto uni√≥n de los conjuntos `a` y `b`.
- `intersect(a, b)`, `a ‚à© b`: Devuelve el conjunto intersecci√≥n de los conjuntos `a` y `b`.
- `setdiff(a, b)`: Devuelve el conjunto diferencia del conjunto `a` y `b`.
- `symdiff(a, b)`: Devuelve el conjunto diferencia sim√©trica de los conjuntos `a` y `b`.


Existen versiones de estas funciones acabadas en `!` que sobreescriben el conjunto dado como primer argumento con el resultado de la operaci√≥n.

---

### Ejemplo de √°lgebra de conjuntos

```julia
julia> a = Set(1:3)
Set{Int64} with 3 elements:
  2
  3
  1

julia> b = Set(2:2:6)
Set{Int64} with 3 elements:
  4
  6
  2

julia> union(a, b)
Set{Int64} with 5 elements:
  4
  6
  2
  3
  1

julia> intersect(a, b)
Set{Int64} with 1 element:
  2

julia> setdiff(a, b)
Set{Int64} with 2 elements:
  3
  1

julia> symdiff(a, b) == setdiff(a ‚à™ b, a ‚à© b)
true
```

---

# Funciones

## Creaci√≥n de funciones

Una funci√≥n asocia un nombre a un bloque de c√≥digo de manera que cada vez que se invoca a la funci√≥n se ejecuta el bloque de c√≥digo asociado.

Para crear una funci√≥n se utiliza la siguiente sintaxis

> `function` _nombre_`(`_par√°metros_`)`  
    &nbsp;&nbsp;&nbsp;bloque de c√≥digo  
  `end`


:::{.callout-note}
La indentaci√≥n del bloque de c√≥digo no es necesaria pero es una buena pr√°ctica.
:::

Para invocar una funci√≥n basta con escribir su nombre y pasarle entre par√©ntesis los valores de los par√°metros (_argumentos_) separados por comas.

---

### Ejemplo de creaci√≥n de funciones

```julia
julia> function saludo()  # Funci√≥n sin par√°metros
         println("¬°Bienvenido!")
       end
saludo (generic function with 1 method)

julia> saludo()
¬°Bienvenido!

julia> typeof(saludo)
typeof(saludo) (singleton type of function saludo, subtype of Function)
```

---

## Par√°metros y argumentos de una funci√≥n

Una funci√≥n puede recibir valores cuando se invoca a trav√©s de unas variables conocidas como _par√°metros_ que se definen entre par√©ntesis y separados por comas en la declaraci√≥n de la funci√≥n. En el cuerpo de la funci√≥n se pueden usar estos par√°metros como si fuesen variables.

Los valores que se pasan a la funci√≥n en una llamada o invocaci√≥n concreta de ella se conocen como _argumentos_ y se asocian a los par√°metros de la declaraci√≥n de la funci√≥n.

```julia
julia> function calificacion(nota)  # Funci√≥n con un par√°metro
         if nota < 5
           println("Suspenso")
         else
           println("Aprobado")
         end
       end
calificacion (generic function with 1 method)

julia> calificacion(7)
Aprobado
```

---

### Paso de argumentos a una funci√≥n

Los argumentos se pueden pasar de dos formas:

- **Argumentos posicionales**: Se asocian a los par√°metros de la funci√≥n en el mismo orden que aparecen en la definici√≥n de la funci√≥n.
- **Argumentos nominales**: Se indica expl√≠citamente el nombre del par√°metro al que se asocia un argumento de la forma `parametro = argumento`.

Cuando una funci√≥n tiente par√°metros posicionales y como nominales, los posicionales deben indicarse primero y los nominales despu√©s, separando ambos tipos de par√°metros por punto y coma `;`.

---

### Ejemplo de paso de argumentos a una funci√≥n

```julia
julia> function saludo(nombre, apellidos; ciudad)
       println("¬°Hola $nombre $apellidos, bienvenido a $(ciudad)!")
       end
saludo (generic function with 1 method)

julia> saludo("Alfredo", "S√°nchez", ciudad = "Madrid")
¬°Hola Alfredo S√°nchez, bienvenido a Madrid!

julia> saludo("Alfredo", ciudad = "Madrid",  "S√°nchez")
¬°Hola Alfredo S√°nchez, bienvenido a Madrid!
```

---

### Argumentos por defecto

En la definici√≥n de una funci√≥n se puede asignar a cada par√°metro un argumento por defecto, de manera que si se invoca la funci√≥n sin proporcionar ning√∫n argumento para ese par√°metro, se utiliza el argumento por defecto.

El valor por defecto de un par√°metro se indica con la siguiente sintaxis `par√°metro = valor`.

```julia
julia> function saludo(nombre, apellidos, ciudad = "Madrid")
         println("¬°Hola $nombre $apellidos, bienvenido a $(ciudad)!")
       end
saludo (generic function with 2 methods)

julia> saludo("Alfredo", "S√°nchez")
¬°Hola Alfredo S√°nchez, bienvenido a Madrid!

julia> saludo("Pepito", "Grillo", "Barcelona")
¬°Hola Pepito Grillo, bienvenido a Barcelona!
```

---

### Funciones con un n√∫mero variable de argumentos

Julia permite definir funciones que pueden llamarse con un n√∫mero variable de argumentos. Para que una funci√≥n pueda recibir un n√∫mero variable de argumentos hay que poner tres puntos suspensivos `...` al final de √∫ltimo par√°metro posicional.

Cuando se llame a la funci√≥n los argumentos se ir√°n asociando a los par√°metros posicionales en orden y el √∫ltimo par√°metro se asociar√° a una tupla con el resto de argumentos en la llamada.

```julia
julia> function media(x...)
       println("Media de ", x)
       sum(x) / length(x)
       end
media (generic function with 1 method)

julia> media(1, 2, 3, 4)
Media de (1, 2, 3, 4)
2.5
```

---

### Par√°metros con tipo

Aunque Julia es un lenguaje de tipado din√°mico tambi√©n permite fijar el tipo de los par√°metros de una una funci√≥n. Esto permite definir diferentes variantes (_m√©todos_) de una misma funci√≥n dependiendo del tipo de los argumentos, as√≠ como detectar errores cuando se llama a la funci√≥n con argumentos de distinto tipo.

Para indicar el tipo de los par√°metros de una funci√≥n se utiliza la sintaxis `parametro::tipo`.

:::{.callout-warning}
Conviene no restringir demasiado el tipo de los par√°metros de una funci√≥n. Se debe elegir el tipo m√°s general en la jerarqu√≠a de tipos para el que tiene sentido la funci√≥n.
:::

---

### Ejemplo de par√°metros con tipo

```julia
julia> function sumar(x::Number, y::Number)
       x + y
       end
sumar (generic function with 1 method)

julia> function sumar(x::String, y::String)
       x * y
       end
sumar (generic function with 2 methods)

julia> sumar(1, 2)
3

julia> sumar(1.5, 2.5)
4.0

julia> sumar("Hola", "Julia")
"HolaJulia"
```

---

### Paso de argumentos por asignaci√≥n

En Julia los argumentos se pasan a una funci√≥n por asignaci√≥n, es decir, se asignan a los par√°metros de la funci√≥n como si fuesen variables locales. De este modo, cuando los argumentos son objetos mutables (arrays, diccionarios, etc.) se pasa al par√°metro una referencia al objeto, de manera que cualquier cambio que se haga en la funci√≥n mediante el par√°metro asociado afectar√° al objeto original y ser√°n visibles fuera de ella.


```julia
julia> function matricular(curso, asignatura)
       push!(curso, asignatura)
       end
matricular (generic function with 1 method)

julia> primer_curso = [];

julia> matricular(primer_curso, "√Ålgebra Lineal");

julia> matricular(primer_curso, "Programaci√≥n");

julia> primer_curso
2-element Vector{Any}:
 "√Ålgebra Lineal"
 "Programaci√≥n"
```

---

### √Åmbito de los par√°metros de una funci√≥n

Los par√°metros y las variables declaradas dentro de una funci√≥n son de _√°mbito local_, mientras que las variable definidas fuera de funciones son de √°mbito _√°mbito global_.

Tanto los par√°metros como las variables del √°mbito local de una funci√≥n s√≥lo est√°n accesibles durante la ejecuci√≥n de la funci√≥n. Es decir, cuando termina la ejecuci√≥n de la funci√≥n estas variables desaparecen y no son accesibles desde fuera de la funci√≥n.

Si en el √°mbito local de una funci√≥n existe una variable que tambi√©n existe en el √°mbito global, durante la ejecuci√≥n de la funci√≥n la variable global queda eclipsada por la variable local y no es accesible hasta que finaliza la ejecuci√≥n de la funci√≥n.

---

### Ejemplo del √°mbito de los par√°metros de una funci√≥n

```julia
julia> lenguaje = "Python";

julia> function saludo(nombre)
       lenguaje = "Julia"
       println("¬°Hola $(nombre), bienvenido a $(lenguaje)!")
       end
saludo (generic function with 3 methods)

julia> saludo("Alf")
¬°Hola Alf, bienvenido a Julia!

julia> lenguaje
"Python"

julia> nombre
ERROR: UndefVarError: nombre not defined
```

## Retorno de una funci√≥n

Una funci√≥n devuelve siempre el valor de la √∫ltima expresi√≥n evaluada en su cuerpo. Sin embargo, puede devolverse cualquier otro valor indic√°ndolo detr√°s de la palabra reservada `return`. Cuando el flujo de ejecuci√≥n de la funci√≥n alcanza esta palabra, la ejecuci√≥n de la funci√≥n termina y se devuelve el valor que la acompa√±a.

Si una funci√≥n no devuelve ning√∫n valor se puede escribir la palabra `return` sin nada m√°s. 

Cuando se desea devolver m√°s de un valor se puede pueden indicar separados por comas y la funci√≥n devolver√° la tupla formada por esos valores.

---

### Ejemplo de retorno de una funci√≥n

```julia
julia> function area_triangulo(base, altura)
         return base * altura / 2  # Devuelve un valor
       end
area_triangulo (generic function with 1 method)

julia> area_triangulo(3, 4)
6.0

julia> function area_perimetro_circulo(r)
         return œÄ * r ^ 2, 2œÄ * r  # Devuelve dos valores 
       end
area_perimetro_circulo (generic function with 1 method)

julia> area_perimetro_circulo(1)
(3.141592653589793, 6.283185307179586)
```

## Funciones compactas

Cuando el cuerpo de una funci√≥n es una √∫nica expresi√≥n se puede definir la funci√≥n de forma mucho m√°s compacta de la siguiente manera:

> `nombre(`_parametros_`)` `=` _expresi√≥n_

El valor que devuelve la funci√≥n es el resultado de evaluar la expresi√≥n.

Esta forma de definir funciones es muy habitual para funciones matem√°ticas.

```julia
julia> area_triangulo(b, a) = b * a / 2
area_triangulo (generic function with 1 method)

julia> area_triangulo(3, 4)
6.0

julia> valor_absoluto(x) = x < 0 ? -x : x
valor_absoluto (generic function with 1 method)

julia> valor_absoluto(-1)
1
```

## Funciones como objetos

En Julia las funciones son objetos como el resto de tipos de datos, de manera que es posible asignar una funci√≥n a una variable y luego utilizar la variable para hacer la llamada a la funci√≥n, pasar una funci√≥n como argumento de otra funci√≥n, o que una funci√≥n devuelva otra funci√≥n.

```julia
julia> suma(x, y) = x + y
suma (generic function with 1 method)

julia> adicion = suma
suma (generic function with 1 method)

julia> adicion(1, 2)
3

julia> calculadora(operador, x, y) = operador(x, y) 
calculadora (generic function with 1 method)

julia> calculadora(suma, 1, 2)
3
```

---

## Funciones an√≥nimas

Julia permite tambi√©n definir funciones sin nombre. Para ello se utiliza la siguiente sintaxis. 

> `(`_parametros_`)` `->` _expresi√≥n_

El principal uso de las funciones an√≥nimas es para pasarlas como argumentos de otras funciones. 

```julia
ulia> calculadora(operador, x, y) = operador(x, y) 
calculadora (generic function with 1 method)

julia> calculadora((x, y) -> x + y, 1, 2)
3

julia> calculadora((x, y) -> x - y, 1, 2)
-1
```

---

## Funciones asociadas a operadores

En Julia los operadores tienen asociadas funciones que son llamadas por el int√©rprete cuando se eval√∫a una expresi√≥n con operadores. 

```julia
julia> +(1, 2, 3)  # Equivalente a 1 + 2 + 3
6

julia> ‚àë = +
+ (generic function with 208 methods)

julia> ‚àë(1, 2, 3)
6
```

## Funciones recursivas

Una funci√≥n recursiva es una funci√≥n que en su cuerpo contiene alguna llama a si misma. 

La recursi√≥n es una pr√°ctica com√∫n en la mayor√≠a de los lenguajes de programaci√≥n ya que permite resolver las tareas recursivas de manera m√°s natural.

Para garantizar el final de una funci√≥n recursiva, las sucesivas llamadas tienen que reducir el grado de complejidad del problema, hasta que este pueda resolverse directamente sin necesidad de volver a llamar a la funci√≥n.

:::{.callout-caution}
La recursi√≥n es una t√©cnica que suele ser poco eficiente computacionalmente y conviene evitarla siempre que sea posible.
:::

---

### Ejemplo de funciones recursivas

```julia
julia> function factorial(n::Integer)
         if n <= 1
           return 1
         else
           return n * factorial(n-1)
         end
       end
factorial (generic function with 1 method)

julia> factorial(4)
24

julia> fib(n::Integer) = n ‚â§ 2 ? 1 : fib(n - 1) + fib(n - 2)
fib (generic function with 1 method)

julia> fib(10)
55
```

<!-- TODO: Comentarios de funciones -->

# Gr√°ficos

## Paquetes gr√°ficos

Existen muchos paquetes para la representaci√≥n gr√°fica en Julia. Los m√°s usados son:

- [Plots.jl](https://docs.juliaplots.org/)
- [GadFly.jl](http://gadflyjl.org/).
- [VegaLite.jl](https://www.queryverse.org/VegaLite.jl/stable/)


## Gr√°ficos con el paquete Plots.jl

[Plots.js](https://docs.juliaplots.org/) es el paquete m√°s usado por disponer de m√°s posibilidades gr√°ficas y ser bastante sencillo de usar.

Implementa una interfaz para otras librer√≠as gr√°ficas (backends), por lo que en algunas ocasiones puede ser bastante lento al tener que llamar a otras librer√≠as. 

![](img/logos/plotsjl.png)

---

### Backends de Plot.jl

- [GR](https://gr-framework.org/). Es el backend pro defecto. Es bastante r√°pida y permite tanto gr√°ficos 2D como 3D no interactivos. Se inicializa con la funci√≥n `gr()`. ([Ver ejemplos](https://docs.juliaplots.org/latest/gallery/gr/))
- [PlotlyJS](https://plotly.com/). Es m√°s lenta pero permite gr√°ficos 2D y 3D interactivos con un mont√≥n de funcionalidades. Se inicializa con la funci√≥n `plotlyjs()`. ([Ver ejemplos](https://docs.juliaplots.org/latest/gallery/plotlyjs/))
- [PyPlot](https://matplotlib.org/). Utiliza la librer√≠a gr√°fica Matplotlib de Python por lo que es bastante lenta. Sin embargo, tiene ofrece todas las posibilidades de Matplotlib que es bastante madura. Se inicializa con la funci√≥n `pyplot()`. ([Ver ejemplos](https://docs.juliaplots.org/latest/gallery/pyplot/))
- [PGFPlotsX](). Utiliza la librer√≠a PGF/TikZ de $\LaTeX$ por lo que genera gr√°ficos de muy alta calidad tanto en 2D como 3D, especialmente para publicaciones.Se inicializa con la funci√≥n `pgfplotsx()`. ([Ver ejemplos](https://docs.juliaplots.org/latest/gallery/pgfplotsx/))
- UnicodePlots. Permite dibujar gr√°ficos en la terminal. Los gr√°ficos son de poca calidad pero funciona con gran rapidez. Se inicializa con la funci√≥n `unicodeplots()`. ([Ver ejemplos](https://docs.juliaplots.org/latest/gallery/unicodeplots/))

---

### Gr√°fica de una funci√≥n de una variable

- `plot(f, min, max)`: Dibuja la gr√°fica de la funci√≥n de una variable `f` para argumentos desde `xmin` a `xmax`. 

```{julia}
using Plots

f(x) = exp(-x^2 / 2)
plot(f, -3, 3)
```

---

### Gr√°fica interactiva de una funci√≥n de una variable

```{julia}
using Plots
#plotly()  # Usar la librer√≠a Plot.ly como back-end

f(x) = exp(-x^2 / 2)
plot(f, -3, 3)
```

---

### Gr√°ficas de varias funciones 

- `plot!(f, xmin, xmax)`: A√±ade la gr√°fica de la funci√≥n de una variable `f` para argumentos desde `xmin` a `xmax` al √∫ltimo gr√°fico realizado.

```{julia}
using Plots

f(x) = sin(x)
g(x) = cos(x)
plot(f, -0, 2œÄ)
plot!(g)
```

---

### A√±adir puntos a una gr√°fica

- `scatter(x, y)`: Dibuja los puntos con coordenadas x en el vector `x` y coordenadas y en el vector `y`.

```{julia}
using Plots

f(x) = sin(x)
g(x) = cos(x)
plot(f, -0, 2œÄ)
plot!(g)
x = [œÄ/4, 5œÄ/4]
y = sin.(x)
scatter!(x, y)
```

---

### Ventana de graficaci√≥n

Es posible restringir el √°rea de graficaci√≥n (rango de valores de los ejes) de una funci√≥n a√±adiendo los par√°metros `xlims =(xmin, xmax)` para establecer el rango del eje x o `ylims = (ymin, ymax)` para establecer el rango del eje y. 

```{julia}
using Plots

f(x) = 1 / x
plot(f, -1, 1, ylims = (-10, 10))
```

---

### Restringir la gr√°fica al dominio

Cuando una funci√≥n no est√° definida para alg√∫n valor del rango de valores del eje x dado, la gr√°fica muestra una l√≠nea recta desde el punto de la gr√°fica anterior hasta el punto siguiente al punto donde la funci√≥n no existe.

Este comportamiento no es deseable puesto que si la funci√≥n no existe en un punto no deber√≠a existir gr√°fica para ese punto. 

La siguiente funci√≥n del paquete `MATH229` se encarga de evitar esto.

- `rangeclamp(f)`: Devuelve una funci√≥n id√©ntica a la funci√≥n `f` excepto para los puntos donde la funci√≥n no existe o es infinito que devuevle `NaN`.

---

### Ejemplo de restringir la gr√°fica al dominio

```{julia}
using Plots
using MTH229

f(x) = 1 / x
plot(rangeclamp(f), -1, 1)
```

---

### Gr√°ficas param√©tricas

La funci√≥n `plot` tambi√©n permite dibujar gr√°ficas de funciones param√©tricas pas√°ndole las funciones de las coordenadas x e y. 

- `plot(f, g, min, max)`: Dibuja la gr√°fica de la funci√≥n param√©trica $(f(t), g(t))$ para valores del par√°metro `t` entre `min` y `max`.

```{julia}
using Plots
f(x) = sin(x)
g(x) = sin(2x)
plot(f, g, 0, 2œÄ)
```

---

### Personalizaci√≥n de gr√°ficos

Los siguientes par√°metros pueden a√±adirse a la funci√≥n `plot` para modificar el aspecto de los gr√°ficos.

- `title`: A√±ade un t√≠tulo principal al gr√°fico.
- `xlab`: A√±ade un t√≠tulo al eje x.
- `ylab`: A√±ade un t√≠tulo al eje y.
- `color`: Establece el color de la gr√°fica.
- `linewidth`: Establece el grosor de la l√≠nea de la gr√°fica.
- `linestyle`: Establece el estilo de la l√≠nea de la gr√°fica.
- `aspect_ratio`: Establece la relaci√≥n de aspecto entre la escala de los ejes.
- `legend`: Activa o desactiva la leyenda del gr√°fico.

---

### Ejemplo de personalizaci√≥n de gr√°ficos

```{julia}
using Plots

f(x) = sin(x)
plot(f, -œÄ, œÄ, title = "Gr√°fica del seno",  xlab = "x", ylab = "f(x) = sen(x)",
  color = "green", linewidth = 3, linestyle = :dash, aspec_ratio = :equal, legend = false)
```

## Gr√°ficos en el espacio real

Para dibujar superficies en el espacio real se utiliza la funci√≥n

`surface(x, y, f)`: Dibuja la superficie de la funci√≥n $f(x,y)$ en el rango de valores `x` del eje x e `y` del eje y.

```{julia}
using Plots
pyplot()
x = range(1, stop=10, length=100)
y = x
f(x,y) = sin(x) + cos(y)
plot(x, y, f, st=:surface)
```

## Gr√°ficos con GadFly.jl

[GadFly.js](http://gadflyjl.org/) es un paquete nativo que genera gr√°ficos interactivos 2D y 3D por medio de librer√≠as de Javascript basadas en la [gram√°tica de gr√°ficos](https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html) (usada tambi√©n por el paquete ggplot2 de R).

Al estar implementado en Julia es mucho m√°s r√°pido que Plots.js pero ofrece menos posibilidades.

![](img/logos/gadfly.svg)

<!-- ---

### Gr√°fica de una funci√≥n de una variable

```julia
using Gadfly

plot([sin, cos], 0, 2pi)
``` -->

## Gr√°ficos con VegaLite.jl

[VegaLite.jl](https://www.queryverse.org/VegaLite.jl/stable/) es un paquete que genera gr√°ficos est√°ticos por medio de las librer√≠as de Javascript de la gram√°tica de gr√°ficos [Vega](https://vega.github.io/). 

Dispone de muchas m√°s opciones de personalizaci√≥n de gr√°ficos que GadFly.jl.

![](img/logos/vega-little.png)

<!-- ---

### Gr√°fica de una funci√≥n de una variable

```julia
using VegaLite

@vlplot(
    width=300,
    height=150,
    data={sequence={start=0,stop=12.7,step=0.1,as="x"}},
    transform=[
        {calculate="sin(datum.x)", as="sin(x)"},
        {calculate="cos(datum.x)", as="cos(x)"},
        {fold=["sin(x)", "cos(x)"]}
    ],
    mark=:line,
    x="x:q",
    y="value:q",
    color={"key:n",title=nothing}
)
``` -->

# C√°lculo simb√≥lico

## Symbolics.jl

`Symbolics.jl` es un paquete que implenta un avanzado Sistema de √Ålgebra Computacional (CAS) basado en un lenguaje de modelado simb√≥lico. 

Las variables y las expresiones simb√≥licas pueden utilizarse con la mayor√≠a de las funciones de Julia para c√°lculo num√©rico, por lo que se integran a la perfecci√≥n en el ecosistema de Julia. 

![](img/logos/juliasymbolics.png)

---

### Variables y expresione simb√≥licas

Para declarar variables simb√≥licas se utiliza la siguiente macro:

- `variables x y ...`: Declara las variables `x`, `y`, etc. como variables simb√≥licas.

El tipo de las variables simb√≥licas es `Num`.

Cualquier expresi√≥n en la que interviene una variable simb√≥lica se convierte autom√°ticamente en una expresi√≥n simb√≥lica.

---

### Ejemplo de variables y expresiones simb√≥licas

```julia
using Symbolics

julia> @variables x y
2-element Vector{Num}:
 x
 y

julia> z = x^2 - y
x^2 - y

julia> typeof(z)
Num

julia> A = [x + y 2x; -y y - x]  # Matriz simb√≥lica
2√ó2 Matrix{Num}:
 x + y     2x
    -y  y - x
```

---

### √Ålgebra simb√≥lica

Se pueden realizar operaciones algebr√°icas con expresiones simb√≥licas utilizando los mismos operadores del √Ålgebra num√©rica.

```julia
using Symbolics

julia> @variables x y;

julia> (x + 1) + (x + 2)
3 + 2x

julia> A = [x + y 2x; -y y - x]  # Matriz simb√≥lica
2√ó2 Matrix{Num}:
 x + y     2x
    -y  y - x

julia> B = [x, y]  # Vector simb√≥lico
2-element Vector{Num}:
 x
 y

julia> A * B  # Producto matricial
2-element Vector{Num}:
 x*(x + y) + 2x*y
  y*(y - x) - x*y
```

---

### Simplicaci√≥n de expresiones

Para simplificar expresiones simb√≥licas se utiliza la siguiente funci√≥n:

- `simplify(e)`: Devuelve la expresi√≥n simb√≥lica que resulta de simplicar la expresi√≥n simb√≥lica `e`.

La simplificaci√≥n utiliza el paquete `SymbolicUtils.jl` que implementa un potente sistema de reescritura de t√©rminos.

```julia
using Symbolics

@variables x y;

julia> simplify(2(x+y))
2x + 2y

julia> simplify(2(x+y))
2x + 2y

julia> simplify(sin(x)^2 + cos(x)^2)
1
```

---

### Sustituci√≥n de variables en expresiones

Para sustituir una variable simb√≥lica en una expresi√≥n se utiliza la siguiente funci√≥n:

- `substitute(e, d)`: Realiza la sustituci√≥n de las claves por los valores del diccionario `d` en la expresi√≥n simb√≥lica `e`.

```julia
using Symbolics

@variables x y;

julia> substitute(cos(2x), Dict([x => œÄ])) 
1.0

julia> substitute(x * y + 2x -y + 2, Dict([x => 1, y => 2]))
4
```

---

### Resoluci√≥n de ecuaciones

Para definir una ecuaci√≥n se utiliza el s√≠mbolo `~` en lugar de la igualdad. 

Para resolver una ecuaci√≥n se utiliza la siguiente funci√≥n:

- `Symbolics.solve_for(eq, var)`: Devuelve un vector con los valores de las variables del vector `var` que cumplen la ecuaci√≥n o sistema de ecuaciones `eq`, siempre que la ecuaci√≥n tenga soluci√≥n. 

:::{.callout-warning}
Actualmente solo funciona para ecuaciones lineales.
:::

```julia
using Symbolics

@variables x y;

julia> Symbolics.solve_for(x + y ~ 0, x)
-y

julia> Symbolics.solve_for([x + y ~ 4, x - y ~ 2], [x, y])
2-element Vector{Float64}:
 3.0
 1.0
```

---

### C√°lculo de derivadas

Para calcular la derivada de una funci√≥n se utiliza la siguiente funci√≥n:

- `Symbolics.derivative(f, x)`: Devuelve la expresi√≥n simb√≥lica de la derivada de la funci√≥n `f` con respecto a la variable simb√≥lica `x`.

```julia
using Symbolics

julia> @variables x y;

julia> Symbolics.derivative(exp(x*y), x)
y*exp(x*y)

julia> Symbolics.derivative(Symbolics.derivative(exp(x*y), x), y)
x*y*exp(x*y) + exp(x*y)
```

---

### C√°lculo de derivadas con operadores diferenciales 

Para construir un operador differencial ($\frac{d}{dx}$) se utiliza la siguiente funci√≥n:

- `Differential(x)`: Crea el operador differencial con respecto a la variable simb√≥lica `x`.

Para obtener la funci√≥n derivada, una vez aplicado el operador diferencial a una funci√≥n, es necesario aplicar la siguiente funci√≥n:

- `expand_derivatives(D(f))`: Devuelve la expresi√≥n simb√≥lica que corresonde a la derivada de la funci√≥n `f` con respecto a la variable del operador differencial `D`.

---

### Ejemplo de c√°lculo de derivadas con operadores diferenciales

```julia
using Symbolics

@variables x y;

julia> Dx = Differential(x)
(::Differential) (generic function with 2 methods)

julia> f(x) = sin(x^2)
f (generic function with 1 method)

julia> f1(x) = Dx(f(x))
f1 (generic function with 1 method)

julia> expand_derivatives(f1(x))
2x*cos(x^2)

julia> Dy = Differential(y)
(::Differential) (generic function with 2 methods)

julia> expand_derivatives(Dx(Dy(cos(x*y))))
-sin(x*y) - x*y*cos(x*y)
```

---

### Gradiente y matriz Hessiana de una funci√≥n de varias variables

Para calcular el vector gradiente de una funci√≥n de varias variables se utiliza la siguiente funci√≥n:

- `Symbolics.gradient(f, vars)`: Devuelve el vector gradiente de la funci√≥n `f` con respecto a las variables del vector `vars`.

Y para calcular la matriz Hessiana se utiliza la siguiente funci√≥n:

- `Symbolics.hessian(f, vars)`: Devuelve la matriz Hessiana de la funci√≥n `f` con respecto a las variables del vector `vars`.

---

### Ejemplo de gradiente y matriz hessiana de una funci√≥n de varias variables

```julia
using Symbolics

@variables x y;

julia> Symbolics.gradient(exp(x*y), [x, y])
2-element Vector{Num}:
 y*exp(x*y)
 x*exp(x*y)

julia> Symbolics.hessian(exp(x*y), [x, y])
2√ó2 Matrix{Num}:
 (y^2)*exp(x*y)               x*y*exp(x*y) + exp(x*y)
   x*y*exp(x*y) + exp(x*y)  (x^2)*exp(x*y)
```

# An√°lisis de datos

## El paquete DataFrames.jl

El principal paquete para an√°lisis de datos es [`DataFrames.jl`](https://dataframes.juliadata.org/stable/) que proporciona herramientas para trabajar con conjuntos de datos en formato de tabla de forma similiar a pandas en Python o data.frames y dplyr en R.

En conjunci√≥n con este paque es frecuente utilizar tambi√©n alguno de los siguientes paquetes:

- [FreqTables.jl](https://github.com/nalimilan/FreqTables.jl). Funciones para la construcci√≥n de tablas de frecuencias.
- [Statistics.jl](https://docs.julialang.org/en/v1/stdlib/Statistics/). Funciones para los principales estad√≠sticos descriptivos.
- [HypothesisTests.jl](https://juliastats.org/HypothesisTests.jl/stable/) Funciones para los contrastes de hip√≥tesis param√©tricos y no param√©tricos m√°s comunes.
- [GLM.jl](https://juliastats.org/GLM.jl/stable/). Funciones para modelos lineales generales.
- [MultivariateStats.jl](https://multivariatestatsjl.readthedocs.io/en/stable/index.html). Funciones para an√°lisis multivariante.
- [MLJ.jl](https://github.com/alan-turing-institute/MLJ.jl). Funciones para los principales algoritmos de aprendizaje autom√°tico.

---

### Creaci√≥n de DataFrames

Para crear un DataFrame su utiliza la siguiente funci√≥n: 

- `DataFrame(x1=v1, x2=v2, ...)`: Devuelve el DataFrame que formado por las columnas de los vectores `v1`, `v2`, etc, con los nombres `x1`, `x2`, etc, respectivamente.

```julia
using DataFrames

julia> df = DataFrame(Nombre = ["Mar√≠a", "Luis", "Carmen"], Edad = [22, 18, 20])
3√ó2 DataFrame
 Row ‚îÇ Nombre  Edad  
     ‚îÇ String  Int64 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ Mar√≠a      22
   2 ‚îÇ Luis       18
   3 ‚îÇ Carmen     20
```

---

### Creaci√≥n de DataFrames desde una url

Para crear una DataFrame a partir de un fichero csv en la nube, se utiliza la siguiente funci√≥n del paquete `CSV.jl`:

- `CSV.read(download(url), DataFrame)`: Devuelve el DataFrame que resulta de importar el fichero csv con la url `url`.

```julia
using DataFrames, CSV

julia> df = CSV.read(download("https://raw.githubusercontent.com/asalber/manual-python/master/datos/colesteroles.csv"), DataFrame)
14√ó6 DataFrame
 Row ‚îÇ nombre                           edad   sexo     peso     altura   colesterol 
     ‚îÇ String                           Int64  String1  Int64?   String7  Int64?     
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ Jos√© Luis Mart√≠nez Izquierdo        18  H             85  1,79            182
   2 ‚îÇ Rosa D√≠az D√≠az                      32  M             65  1,73            232
   3 ‚îÇ Javier Garc√≠a S√°nchez               24  H        missing  1,81            191
   4 ‚îÇ Carmen L√≥pez Pinz√≥n                 35  M             65  1,70            200
   5 ‚îÇ Marisa L√≥pez Collado                46  M             51  1,58            148
   6 ‚îÇ Antonio Ruiz Cruz                   68  H             66  1,74            249
   7 ‚îÇ Antonio Fern√°ndez Oca√±a             51  H             62  1,72            276
   8 ‚îÇ Pilar Mart√≠n Gonz√°lez               22  M             60  1,66        missing 
   9 ‚îÇ Pedro G√°lvez Tenorio                35  H             90  1,94            241
  10 ‚îÇ Santiago Reillo Manzano             46  H             75  1,85            280
  11 ‚îÇ Macarena √Ålvarez Luna               53  M             55  1,62            262
  12 ‚îÇ Jos√© Mar√≠a de la Gu√≠a Sanz          58  H             78  1,87            198
  13 ‚îÇ Miguel Angel Cuadrado Guti√©rrez     27  H            109  1,98            210
  14 ‚îÇ Carolina Rubio Moreno               20  M             61  1,77            194
```


# Aplicaciones

## Teor√≠a de grafos

- [JuliaGraphs](https://juliagraphs.org/). Graphs analysis in Julia.

## C√°lculo simb√≥lico

- [SymPy](https://docs.juliahub.com/SymPy/KzewI/1.0.31/). Sistema de √Ålgebra Computacional (CAS) basdado en la librer√≠a `SymPy` de Python.
- [Symbolics](https://juliasymbolics.org/) Sistema de √Ålgebra Computacional (CAS) basado en Julia.



